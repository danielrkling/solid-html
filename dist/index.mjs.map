{"version":3,"file":"index.mjs","names":["code: number","strings: TemplateStringsArray | string[]","rawTextElements: Set<string>","tokens: Token[]","quoteChar: '\"' | \"'\" | \"\"","rawTextElements","tokens: Token[]","voidElements: Set<string>","root: RootNode","stack: (RootNode | ElementNode)[]","node: ElementNode","parts: (string | number)[]","voidElements","value: any","tag: string","arr: any[]","node: ElementNode","node: RootNode | ChildNode","node: ChildNode","components: T","sld","strings: TemplateStringsArray","newComponents: TNew","node: ChildNode","values: any[]","components: ComponentRegistry","node: RootNode | ElementNode","nodes: ChildNode[]","node","node: ElementNode","props: Record<string, any>","spread","name: string","value: any","component: T"],"sources":["../src/tokenize.ts","../src/parse.ts","../src/util.ts","../src/template.ts","../src/sld.ts","../src/index.ts"],"sourcesContent":["export const OPEN_TAG_TOKEN = 0;\r\nexport const CLOSE_TAG_TOKEN = 1;\r\nexport const SLASH_TOKEN = 2;\r\nexport const IDENTIFIER_TOKEN = 3;\r\nexport const EQUALS_TOKEN = 4;\r\nexport const ATTRIBUTE_VALUE_TOKEN = 5;\r\nexport const TEXT_TOKEN = 6;\r\nexport const EXPRESSION_TOKEN = 7;\r\nexport const QUOTE_CHAR_TOKEN = 8;\r\n\r\nexport type TokenType =\r\n  | typeof OPEN_TAG_TOKEN\r\n  | typeof CLOSE_TAG_TOKEN\r\n  | typeof SLASH_TOKEN\r\n  | typeof IDENTIFIER_TOKEN\r\n  | typeof EQUALS_TOKEN\r\n  | typeof ATTRIBUTE_VALUE_TOKEN\r\n  | typeof TEXT_TOKEN\r\n  | typeof EXPRESSION_TOKEN\r\n  | typeof QUOTE_CHAR_TOKEN;\r\n\r\n// Character code helpers for fast path testing (faster than regex)\r\nconst isIdentifierChar = (code: number): boolean => {\r\n  return (\r\n    (code >= 48 && code <= 57) || // 0-9\r\n    (code >= 65 && code <= 90) || // A-Z\r\n    (code >= 97 && code <= 122) || // a-z\r\n    code === 46 || // .\r\n    code === 58 || // :\r\n    code === 95 || // _\r\n    code === 45\r\n  ); // -\r\n};\r\n\r\nconst isWhitespace = (code: number): boolean => {\r\n  return (code >= 9 && code <= 13) || code === 32; // \\t \\n \\v \\f \\r space\r\n};\r\n\r\nexport interface OpenTagToken {\r\n  type: typeof OPEN_TAG_TOKEN;\r\n  value: \"<\";\r\n}\r\n\r\nexport interface CloseTagToken {\r\n  type: typeof CLOSE_TAG_TOKEN;\r\n  value: \">\";\r\n}\r\n\r\nexport interface SlashToken {\r\n  type: typeof SLASH_TOKEN;\r\n  value: \"/\";\r\n}\r\n\r\nexport interface IdentifierToken {\r\n  type: typeof IDENTIFIER_TOKEN;\r\n  value: string;\r\n}\r\n\r\nexport interface EqualsToken {\r\n  type: typeof EQUALS_TOKEN;\r\n  value: \"=\";\r\n}\r\n\r\nexport interface AttributeValueToken {\r\n  type: typeof ATTRIBUTE_VALUE_TOKEN;\r\n  value: string;\r\n}\r\n\r\nexport interface TextToken {\r\n  type: typeof TEXT_TOKEN;\r\n  value: string;\r\n}\r\n\r\nexport interface ExpressionToken {\r\n  type: typeof EXPRESSION_TOKEN;\r\n  value: number;\r\n}\r\n\r\n\r\nexport interface QuoteCharToken {\r\n  type: typeof QUOTE_CHAR_TOKEN;\r\n  value: \"'\" | '\"';\r\n}\r\n\r\nexport type Token =\r\n  | OpenTagToken\r\n  | CloseTagToken\r\n  | SlashToken\r\n  | IdentifierToken\r\n  | EqualsToken\r\n  | AttributeValueToken\r\n  | TextToken\r\n  | ExpressionToken\r\n  | QuoteCharToken;\r\n\r\n\r\n\r\n// Add a new state for elements that contain raw text only\r\nconst STATE_TEXT = 0;\r\nconst STATE_TAG = 1;\r\nconst STATE_ATTR_VALUE = 2;\r\nconst STATE_RAW_TEXT = 3;\r\n\r\nexport function tokenize(\r\n  strings: TemplateStringsArray | string[],\r\n  rawTextElements: Set<string>,\r\n): Token[] {\r\n  const tokens: Token[] = [];\r\n  let state = STATE_TEXT;\r\n  let quoteChar: '\"' | \"'\" | \"\" = \"\";\r\n  let lastTagName = \"\"; \r\n  let cursor = 0;\r\n\r\n  for (let i = 0; i < strings.length; i++) {\r\n    const str = strings[i];\r\n    const len = str.length;\r\n    cursor = 0;\r\n\r\n    while (cursor < len) {\r\n      if (state === STATE_TEXT) {\r\n        const nextTag = str.indexOf(\"<\", cursor);\r\n        if (nextTag === -1) {\r\n          if (cursor < len) tokens.push({ type: TEXT_TOKEN, value: str.slice(cursor) });\r\n          cursor = len;\r\n        } else {\r\n          if (nextTag > cursor) tokens.push({ type: TEXT_TOKEN, value: str.slice(cursor, nextTag) });\r\n          \r\n          const nextCode = str.charCodeAt(nextTag + 1);\r\n          // Case-sensitive identifier check remains the same\r\n          if (nextCode === 47 || isIdentifierChar(nextCode)) {\r\n            tokens.push({ type: OPEN_TAG_TOKEN, value: \"<\" });\r\n            state = STATE_TAG;\r\n            cursor = nextTag + 1;\r\n          } else {\r\n            tokens.push({ type: TEXT_TOKEN, value: \"<\" });\r\n            cursor = nextTag + 1;\r\n          }\r\n        }\r\n      } \r\n      \r\n      else if (state === STATE_TAG) {\r\n        const char = str[cursor];\r\n        const code = str.charCodeAt(cursor);\r\n\r\n        if (isWhitespace(code)) {\r\n          cursor++;\r\n        } else if (char === \">\") {\r\n          tokens.push({ type: CLOSE_TAG_TOKEN, value: \">\" });\r\n          \r\n          // Case-sensitive lookup\r\n          if (rawTextElements.has(lastTagName)) {\r\n            state = STATE_RAW_TEXT;\r\n          } else {\r\n            state = STATE_TEXT;\r\n          }\r\n          cursor++;\r\n        } else if (char === \"=\") {\r\n          tokens.push({ type: EQUALS_TOKEN, value: char });\r\n          cursor++;\r\n        } else if (char === \"/\") {\r\n          tokens.push({ type: SLASH_TOKEN, value: char });\r\n          cursor++;\r\n        } else if (char === '\"' || char === \"'\") {\r\n          tokens.push({ type: QUOTE_CHAR_TOKEN, value: char });\r\n          quoteChar = char;\r\n          state = STATE_ATTR_VALUE;\r\n          cursor++;\r\n        } else if (isIdentifierChar(code)) {\r\n          const start = cursor;\r\n          while (cursor < len && isIdentifierChar(str.charCodeAt(cursor))) cursor++;\r\n          // Capture tag name exactly as it appears\r\n          lastTagName = str.slice(start, cursor);\r\n          tokens.push({ type: IDENTIFIER_TOKEN, value: lastTagName });\r\n        } else {\r\n          cursor++;\r\n        }\r\n      } \r\n      \r\n      else if (state === STATE_ATTR_VALUE) {\r\n        const endQuoteIndex = str.indexOf(quoteChar, cursor);\r\n        if (endQuoteIndex === -1) {\r\n          tokens.push({ type: ATTRIBUTE_VALUE_TOKEN, value: str.slice(cursor) });\r\n          cursor = len;\r\n        } else {\r\n          if (endQuoteIndex > cursor) {\r\n            tokens.push({ type: ATTRIBUTE_VALUE_TOKEN, value: str.slice(cursor, endQuoteIndex) });\r\n          }\r\n          tokens.push({ type: QUOTE_CHAR_TOKEN, value: quoteChar as any });\r\n          state = STATE_TAG;\r\n          quoteChar = \"\";\r\n          cursor = endQuoteIndex + 1;\r\n        }\r\n      }\r\n\r\n      else if (state === STATE_RAW_TEXT) {\r\n        // Case-sensitive search for the specific closing tag\r\n        const closeTagStr = `</${lastTagName}>`;\r\n        const endOfRawIdx = str.indexOf(closeTagStr, cursor);\r\n\r\n        if (endOfRawIdx === -1) {\r\n          tokens.push({ type: TEXT_TOKEN, value: str.slice(cursor) });\r\n          cursor = len;\r\n        } else {\r\n          if (endOfRawIdx > cursor) {\r\n            tokens.push({ type: TEXT_TOKEN, value: str.slice(cursor, endOfRawIdx) });\r\n          }\r\n          state = STATE_TEXT;\r\n          cursor = endOfRawIdx; \r\n        }\r\n      }\r\n    }\r\n\r\n    if (i < strings.length - 1) {\r\n      tokens.push({ type: EXPRESSION_TOKEN, value: i });\r\n    }\r\n  }\r\n\r\n  return tokens;\r\n}\r\n","import {\r\n  ATTRIBUTE_VALUE_TOKEN,\r\n  CLOSE_TAG_TOKEN,\r\n  EQUALS_TOKEN,\r\n  EXPRESSION_TOKEN,\r\n  IDENTIFIER_TOKEN,\r\n  IdentifierToken,\r\n  OPEN_TAG_TOKEN,\r\n  QUOTE_CHAR_TOKEN,\r\n  SLASH_TOKEN,\r\n  TEXT_TOKEN,\r\n  Token,\r\n  TokenType,\r\n} from \"./tokenize\";\r\n\r\n// Node type constants\r\nexport const ROOT_NODE = 0;\r\nexport const ELEMENT_NODE = 1;\r\nexport const TEXT_NODE = 2;\r\nexport const EXPRESSION_NODE = 3;\r\n\r\n// Prop type constants\r\nexport const BOOLEAN_PROP = 0;\r\nexport const STATIC_PROP = 1;\r\nexport const EXPRESSION_PROP = 2;\r\nexport const SPREAD_PROP = 3;\r\nexport const MIXED_PROP = 4;\r\n\r\nexport type NodeType =\r\n  | typeof ROOT_NODE\r\n  | typeof ELEMENT_NODE\r\n  | typeof TEXT_NODE\r\n  | typeof EXPRESSION_NODE;\r\nexport type PropType =\r\n  | typeof BOOLEAN_PROP\r\n  | typeof STATIC_PROP\r\n  | typeof EXPRESSION_PROP\r\n  | typeof SPREAD_PROP\r\n  | typeof MIXED_PROP;\r\n\r\nexport interface RootNode {\r\n  type: typeof ROOT_NODE;\r\n  children: ChildNode[];\r\n}\r\n\r\nexport type ChildNode = ElementNode | TextNode | ExpressionNode;\r\n\r\nexport interface ElementNode {\r\n  type: typeof ELEMENT_NODE;\r\n  name: string;\r\n  props: PropNode[];\r\n  children: ChildNode[];\r\n}\r\n\r\nexport interface TextNode {\r\n  type: typeof TEXT_NODE;\r\n  value: string;\r\n}\r\n\r\nexport interface ExpressionNode {\r\n  type: typeof EXPRESSION_NODE;\r\n  value: number;\r\n}\r\n\r\nexport interface BooleanProp {\r\n  name: string;\r\n  type: typeof BOOLEAN_PROP;\r\n  value: boolean;\r\n}\r\n\r\nexport interface StaticProp {\r\n  name: string;\r\n  type: typeof STATIC_PROP;\r\n  value: string;\r\n  quote?: \"'\" | '\"';\r\n}\r\n\r\nexport interface ExpressionProp {\r\n  name: string;\r\n  type: typeof EXPRESSION_PROP;\r\n  value: number;\r\n  quote?: \"'\" | '\"';\r\n}\r\n\r\nexport interface SpreadProp {\r\n  type: typeof SPREAD_PROP;\r\n  value: number;\r\n}\r\n\r\nexport interface MixedProp {\r\n  name: string;\r\n  type: typeof MIXED_PROP;\r\n  value: Array<string | number>;\r\n  quote?: \"'\" | '\"';\r\n}\r\n\r\nexport type PropNode =\r\n  | BooleanProp\r\n  | StaticProp\r\n  | ExpressionProp\r\n  | SpreadProp\r\n  | MixedProp;\r\n\r\nexport function parse(tokens: Token[], voidElements: Set<string>): RootNode {\r\n  const root: RootNode = { type: ROOT_NODE, children: [] };\r\n  const stack: (RootNode | ElementNode)[] = [root];\r\n  let pos = 0;\r\n  const len = tokens.length;\r\n\r\n  while (pos < len) {\r\n    const token = tokens[pos];\r\n    const currentParent = stack[stack.length - 1];\r\n\r\n    // 1. TEXT PATH (with filtering)\r\n    if (token.type === TEXT_TOKEN) {\r\n      const val = token.value;\r\n\r\n      // Optimization: Only trim if the string is small and looks like whitespace\r\n      // Most meaningful text nodes are longer or contain non-whitespace characters\r\n      let shouldPush = true;\r\n      const trimmed = val.trim();\r\n      if (trimmed === \"\") {\r\n        const prev = tokens[pos - 1]?.type;\r\n        const next = tokens[pos + 1]?.type;\r\n        // Filter out if between two tags or at start/end of a tag\r\n        if (\r\n          prev === CLOSE_TAG_TOKEN ||\r\n          prev === OPEN_TAG_TOKEN ||\r\n          next === OPEN_TAG_TOKEN\r\n        ) {\r\n          shouldPush = false;\r\n        }\r\n      }\r\n\r\n      if (shouldPush) {\r\n        currentParent.children.push({ type: TEXT_NODE, value: val });\r\n      }\r\n      pos++;\r\n      continue;\r\n    }\r\n\r\n    // 2. EXPRESSION PATH\r\n    if (token.type === EXPRESSION_TOKEN) {\r\n      currentParent.children.push({\r\n        type: EXPRESSION_NODE,\r\n        value: token.value,\r\n      });\r\n      pos++;\r\n      continue;\r\n    }\r\n\r\n    // 3. TAG PATH\r\n    if (token.type === OPEN_TAG_TOKEN) {\r\n      const next = tokens[pos + 1];\r\n\r\n      // Handle Closing Tag: </name>\r\n      if (next && next.type === SLASH_TOKEN) {\r\n        const nameToken = tokens[pos + 2];\r\n        // Ensure we only pop if the tag matches (prevents stack corruption)\r\n        if (nameToken && nameToken.type === IDENTIFIER_TOKEN) {\r\n          if (\r\n            stack.length > 1 &&\r\n            (stack[stack.length - 1] as ElementNode).name === nameToken.value\r\n          ) {\r\n            stack.pop();\r\n          }\r\n        }\r\n        pos += 4; // skip <, /, name, >\r\n        continue;\r\n      }\r\n\r\n      // Handle Opening Tag: <name ...>\r\n      pos++; // consume <\r\n      const tagName = (tokens[pos++] as IdentifierToken).value;\r\n      const node: ElementNode = {\r\n        type: ELEMENT_NODE,\r\n        name: tagName,\r\n        props: [],\r\n        children: [],\r\n      };\r\n\r\n      // Inline Prop Parsing Loop\r\n      while (pos < len) {\r\n        const t = tokens[pos];\r\n        if (t.type === CLOSE_TAG_TOKEN || t.type === SLASH_TOKEN) break;\r\n\r\n        if (t.type === EXPRESSION_TOKEN) {\r\n          node.props.push({ type: SPREAD_PROP, value: t.value });\r\n          pos++;\r\n          continue;\r\n        }\r\n\r\n        if (t.type === IDENTIFIER_TOKEN) {\r\n          const pName = t.value;\r\n          pos++;\r\n\r\n          if (tokens[pos]?.type === EQUALS_TOKEN) {\r\n            pos++; // consume =\r\n            const valToken = tokens[pos];\r\n\r\n            if (valToken.type === EXPRESSION_TOKEN) {\r\n              node.props.push({\r\n                name: pName,\r\n                type: EXPRESSION_PROP,\r\n                value: valToken.value,\r\n              });\r\n              pos++;\r\n            } else if (valToken.type === QUOTE_CHAR_TOKEN) {\r\n              const q = valToken.value;\r\n              pos++; // consume opening quote\r\n\r\n              let parts: (string | number)[] = [];\r\n              while (pos < len && tokens[pos].type !== QUOTE_CHAR_TOKEN) {\r\n                const part = tokens[pos++];\r\n                if (part.value !== \"\") parts.push(part.value as any);\r\n              }\r\n              pos++; // consume closing quote\r\n\r\n              if (parts.length === 0) {\r\n                node.props.push({\r\n                  name: pName,\r\n                  type: STATIC_PROP,\r\n                  value: \"\",\r\n                  quote: q,\r\n                });\r\n              } else if (parts.length === 1) {\r\n                const v = parts[0];\r\n                node.props.push({\r\n                  name: pName,\r\n                  type: typeof v === \"string\" ? STATIC_PROP : EXPRESSION_PROP,\r\n                  value: v as any,\r\n                  quote: q,\r\n                });\r\n              } else {\r\n                node.props.push({\r\n                  name: pName,\r\n                  type: MIXED_PROP,\r\n                  value: parts,\r\n                  quote: q,\r\n                });\r\n              }\r\n            }\r\n          } else {\r\n            node.props.push({ name: pName, type: BOOLEAN_PROP, value: true });\r\n          }\r\n          continue;\r\n        }\r\n        pos++;\r\n      }\r\n\r\n      currentParent.children.push(node);\r\n\r\n      // Handle Self-Closing/Void Logic\r\n      if (tokens[pos]?.type === SLASH_TOKEN) {\r\n        pos += 2; // skip / and >\r\n      } else if (voidElements.has(tagName)) {\r\n        pos++; // skip >\r\n      } else {\r\n        pos++; // skip >\r\n        stack.push(node); // Move context into this element\r\n      }\r\n      continue;\r\n    }\r\n\r\n    pos++;\r\n  }\r\n\r\n  return root;\r\n}\r\n","import { SVGElements } from \"solid-js/web\";\r\nimport { ElementNode } from \"./parse\";\r\n\r\n\r\nexport function isString(value: any): value is string {\r\n  return typeof value === \"string\";\r\n}\r\n\r\nexport function isNumber(value: any): value is number {\r\n  return typeof value === \"number\";\r\n}\r\n\r\nexport function isFunction(value: any): value is Function {\r\n  return typeof value === \"function\";\r\n}\r\n\r\nexport function isBoolean(value: any): value is boolean {\r\n  return typeof value === \"boolean\";\r\n}\r\n\r\nexport function isObject(value: any): value is object {\r\n  return typeof value === \"object\";\r\n}\r\n\r\nexport function isArray(value: any): value is any[] {\r\n  return Array.isArray(value);\r\n}\r\n\r\nexport const toArray = Array.from;\r\n\r\n\r\nexport const doc = document\r\n\r\nexport const createComment = (data:string)=>doc.createComment(data)\r\n\r\nexport function createElement(tag: string){\r\n  return SVGElements.has(tag) ? doc.createElementNS(\"http://www.w3.org/2000/svg\", tag) : doc.createElement(tag)\r\n}\r\n\r\nexport function flat(arr: any[]) {\r\n  return (arr.length === 1 ? arr[0] : arr);\r\n}\r\n\r\nexport function getValue(value: any) {\r\n  while (isFunction(value)) value = value();\r\n  return value;\r\n}\r\n\r\nexport function isComponentNode(node: ElementNode): boolean {\r\n  return node.name[0] === node.name[0].toUpperCase();\r\n}\r\n\r\nexport function isElementNode(node: ElementNode): boolean {\r\n  return !isComponentNode(node);\r\n}","import { BOOLEAN_PROP, ChildNode, ELEMENT_NODE, EXPRESSION_NODE, ROOT_NODE, STATIC_PROP, TEXT_NODE } from \"./parse\";\r\nimport { createComment, createElement, isComponentNode, isElementNode, isString } from \"./util\";\r\n\r\n\r\n\r\n\r\n//build template element with same exact shape as tree so they can be walked through in sync\r\nexport function buildTemplate(node: RootNode | ChildNode): void {\r\n    if (node.type === ROOT_NODE || isComponentNode(node)) {\r\n        //Criteria for using template is component or root has at least 1 element. May be be a more optimal condition.\r\n        if (node.children.some(isElementNode)) {\r\n            const template = document.createElement(\"template\");\r\n            // buildNodes(node.children, template.content);\r\n            template.innerHTML = node.children.map(buildHTML).join(\"\");\r\n            node.template = template\r\n        }\r\n        node.children.forEach(buildTemplate)\r\n    }\r\n    if (isElementNode(node)) {\r\n        node.children.forEach(buildTemplate)\r\n    }\r\n}\r\n\r\n\r\n//Lets browser handle svg,mathml, and html encoding\r\nfunction buildHTML(node: ChildNode): string {\r\n    switch (node.type) {\r\n        case TEXT_NODE:\r\n            return node.value;\r\n        // case COMMENT_NODE:\r\n        //     return `<!--${node.value}-->`;\r\n        case EXPRESSION_NODE:\r\n            return `<!--+-->`;\r\n        // case COMPONENT_NODE:\r\n        //     return `<!--${node.name}-->`;\r\n        case ELEMENT_NODE:\r\n            let attributeHTML=\"\"\r\n            node.props = node.props.filter((prop) => {\r\n                if (prop.type === STATIC_PROP) {\r\n                    attributeHTML+=` ${prop.name}=\"${prop.value}\"`\r\n                    return;\r\n                } else if (prop.type===BOOLEAN_PROP) {\r\n                    attributeHTML+=` ${prop.name}`\r\n                    return;\r\n                }\r\n                return true;\r\n            });\r\n\r\n\r\n            return `<${node.name}${attributeHTML}>${node.children.map(buildHTML).join(\"\")}</${node.name}>`;\r\n    }\r\n}\r\n\r\n//Building manually requires checking for MathML, SVG tags as well as html encoded chars\r\nfunction buildNodes(nodes: ChildNode[], parent: Node) {\r\n    for (const node of nodes) {\r\n        switch (node.type) {\r\n            case TEXT_NODE:\r\n                parent.appendChild(document.createTextNode(node.value));\r\n                break;\r\n            case COMMENT_NODE:\r\n                parent.appendChild(createComment(node.value));\r\n                break;\r\n            case INSERT_NODE:\r\n                parent.appendChild(createComment(\"+\"));\r\n                break;\r\n            case COMPONENT_NODE:\r\n                parent.appendChild(createComment(node.name));\r\n                break;\r\n            case ELEMENT_NODE:\r\n                const elem = createElement(node.name);\r\n                parent.appendChild(elem);\r\n\r\n                //set static attributes only and remove from props\r\n                node.props = node.props.filter((prop) => {\r\n                    if (prop.type === STRING_PROPERTY) {\r\n                        elem.setAttribute(prop.name, prop.value);\r\n                        return;\r\n                    } else if (prop.type===BOOLEAN_PROPERTY) {\r\n                        elem.setAttribute(prop.name, \"\"); //boolean attribute\r\n                        return;\r\n                    }\r\n                    return true;\r\n                });\r\n                buildNodes(node.children, elem);\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\n","import { JSX, createComponent, mergeProps } from \"solid-js\";\r\nimport { SVGElements, insert, spread } from \"solid-js/web\";\r\nimport {\r\n  parse,\r\n  RootNode,\r\n  ChildNode,\r\n  TEXT_NODE,\r\n  EXPRESSION_NODE,\r\n  ELEMENT_NODE,\r\n  ElementNode,\r\n  ROOT_NODE,\r\n  BOOLEAN_PROP,\r\n  STATIC_PROP,\r\n  EXPRESSION_PROP,\r\n  MIXED_PROP,\r\n  SPREAD_PROP,\r\n} from \"./parse\";\r\nimport { buildTemplate } from \"./template\";\r\nimport { ComponentRegistry, SLDInstance } from \"./types\";\r\nimport {\r\n  createComment,\r\n  createElement,\r\n  flat,\r\n  getValue,\r\n  isComponentNode,\r\n  isFunction,\r\n  isNumber,\r\n  isObject,\r\n  toArray,\r\n} from \"./util\";\r\nimport { tokenize } from \"./tokenize\";\r\n\r\nconst cache = new WeakMap<TemplateStringsArray, RootNode>();\r\n\r\n//Walk over text, comment, and element nodes\r\nconst walker = document.createTreeWalker(document, 133);\r\n\r\nexport const voidElements = new Set([\r\n  \"area\",\r\n  \"base\",\r\n  \"br\",\r\n  \"col\",\r\n  \"embed\",\r\n  \"hr\",\r\n  \"img\",\r\n  \"input\",\r\n  \"link\",\r\n  \"meta\",\r\n  \"param\",\r\n  \"source\",\r\n  \"track\",\r\n  \"wbr\",\r\n]);\r\n\r\nexport const rawTextElements = new Set([\r\n  \"script\",\r\n  \"style\",\r\n  \"textarea\",\r\n  \"title\",\r\n]);\r\n\r\n//Factory function to create new SLD instances.\r\nexport function createSLD<T extends ComponentRegistry>(\r\n  components: T,\r\n): SLDInstance<T> {\r\n  function sld(strings: TemplateStringsArray, ...values: any[]) {\r\n    const root = getCachedRoot(strings);\r\n\r\n    return renderChildren(root, values, components);\r\n  }\r\n  sld.components = components;\r\n  sld.sld = sld;\r\n  sld.define = function define<TNew extends ComponentRegistry>(\r\n    newComponents: TNew,\r\n  ) {\r\n    return createSLD({ ...components, ...newComponents });\r\n  };\r\n\r\n  return sld as SLDInstance<T>;\r\n}\r\n\r\nfunction getCachedRoot(strings: TemplateStringsArray): RootNode {\r\n  let root = cache.get(strings);\r\n  if (!root) {\r\n    root = parse(tokenize(strings, rawTextElements), voidElements);\r\n    buildTemplate(root);\r\n    cache.set(strings, root);\r\n    // console.log(root)\r\n  }\r\n  return root;\r\n}\r\n\r\nfunction renderNode(\r\n  node: ChildNode,\r\n  values: any[],\r\n  components: ComponentRegistry,\r\n): any {\r\n  switch (node.type) {\r\n    case TEXT_NODE:\r\n      return node.value;\r\n    case EXPRESSION_NODE:\r\n      return values[node.value];\r\n    case ELEMENT_NODE:\r\n      const component = components[node.name];\r\n      if (component) {\r\n        return createComponent(\r\n          component,\r\n          gatherProps(node, values, components),\r\n        );\r\n      }\r\n      const element = createElement(node.name);\r\n      spread(\r\n        element,\r\n        gatherProps(node, values, components),\r\n        SVGElements.has(node.name),\r\n        true,\r\n      );\r\n      return element;\r\n  }\r\n}\r\n\r\nfunction renderChildren(\r\n  node: RootNode | ElementNode,\r\n  values: any[],\r\n  components: ComponentRegistry,\r\n): JSX.Element {\r\n  if (!(\"template\" in node)) {\r\n    return flat(node.children.map((n) => renderNode(n, values, components)));\r\n  }\r\n\r\n  const clone = node.template.content.cloneNode(true);\r\n  walker.currentNode = clone;\r\n  walkNodes(node.children);\r\n\r\n  function walkNodes(nodes: ChildNode[]) {\r\n    for (const node of nodes) {\r\n      const domNode = walker.nextNode()!;\r\n      if (node.type === ELEMENT_NODE) {\r\n        if (isComponentNode(node)) {\r\n          insert(\r\n            domNode.parentNode!,\r\n            renderNode(node, values, components),\r\n            domNode,\r\n          );\r\n          walker.currentNode = domNode;\r\n          continue;\r\n        }\r\n        if (node.props.length) {\r\n          //Assigning props to element via assign prop w/effect may be better for performance.\r\n          const props = gatherProps(node, values, components);\r\n          spread(domNode as Element, props, SVGElements.has(node.name), true);\r\n        }\r\n\r\n        walkNodes(node.children);\r\n      } else if (node.type === EXPRESSION_NODE) {\r\n        insert(\r\n          domNode.parentNode!,\r\n          renderNode(node, values, components),\r\n          domNode,\r\n        );\r\n        walker.currentNode = domNode;\r\n      }\r\n    }\r\n  }\r\n  return toArray(clone.childNodes);\r\n}\r\n\r\nfunction gatherProps(\r\n  node: ElementNode,\r\n  values: any[],\r\n  components: ComponentRegistry,\r\n  props: Record<string, any> = {},\r\n) {\r\n  for (const prop of node.props) {\r\n    switch (prop.type) {\r\n      case BOOLEAN_PROP:\r\n        props[prop.name] = true;\r\n        break;\r\n      case STATIC_PROP:\r\n        props[prop.name] = prop.value;\r\n        break;\r\n      case EXPRESSION_PROP:\r\n        applyGetter(props, prop.name, values[prop.value]);\r\n        break;\r\n      case MIXED_PROP:\r\n        const value = () =>\r\n          prop.value\r\n            .map((v) => (isNumber(v) ? getValue(values[v]) : v))\r\n            .join(\"\");\r\n        applyGetter(props, prop.name, value);\r\n        break;\r\n      case SPREAD_PROP:\r\n        const spread = values[prop.value];\r\n        if (!isObject(spread)) throw new Error(\"Can only spread objects\");\r\n        props = mergeProps(props, spread);\r\n        break;\r\n    }\r\n  }\r\n\r\n  // children - childNodes overwrites any props.children\r\n  if (node.children.length) {\r\n    Object.defineProperty(props, \"children\", {\r\n      get() {\r\n        return renderChildren(node, values, components);\r\n      },\r\n    });\r\n  }\r\n  return props;\r\n}\r\n\r\nfunction applyGetter(props: Record<string, any>, name: string, value: any) {\r\n  if (\r\n    isFunction(value) &&\r\n    value.length === 0 &&\r\n    name !== \"ref\" &&\r\n    !name.startsWith(\"on\")\r\n  ) {\r\n    Object.defineProperty(props, name, {\r\n      get() {\r\n        return value();\r\n      },\r\n      enumerable: true,\r\n    });\r\n  } else {\r\n    props[name] = value;\r\n  }\r\n}\r\n","import { createComponent, ErrorBoundary, For, Index, Match, Show, Suspense, Switch } from \"solid-js\";\r\nimport { createSLD, } from \"./sld\";\r\nimport { type FunctionComponent, type SLDInstance } from \"./types\";\r\n\r\nexport { parse } from \"./parse\";\r\nexport { createSLD, SLDInstance };\r\n\r\n/**\r\n * Default components included with SLD. Can be extended with sld.define({MyComponent})\r\n */\r\nexport const defaultComponents = {\r\n    For,\r\n    Index,\r\n    Match,\r\n    Suspense,\r\n    ErrorBoundary,\r\n    Show,\r\n    Switch,\r\n};\r\n\r\n/**\r\n * Default SLD instance with basic components included. Can be extended with sld.define({MyComponent})\r\n */\r\nexport const sld = createSLD(defaultComponents)\r\nexport default sld\r\n\r\n/**\r\n * SLD factory function to create new SLD instances with built-in components.\r\n */\r\nexport const SLD = sld.define\r\n\r\n\r\n\r\n/**\r\n * Helper function for giving better typescript to components. Wrap in createComponent but keep same signature of function. Helps for overlaods.\r\n * @param component Function of component\r\n * @returns \r\n */\r\nexport function run<T extends FunctionComponent>(component: T): T {\r\n    //@ts-expect-error\r\n    return (props)=>createComponent(component, props)\r\n}"],"mappings":"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"}