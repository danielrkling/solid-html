{"version":3,"file":"index.mjs","names":["value: any","data:string","tag: string","node: Element","name: string","value: any","prev?: any","namespace: string","rules: AssignmentRule[]","elem: Element","assign","props: any","prev: any","strings: TemplateStringsArray","arr: any[]","value: any","components: ComponentRegistry","rules: AssignmentRule[]","html","template: HTMLTemplateElement","componentNode: ComponentNode | RootNode","nodes: TreeNode[]","node: TreeNode","parts: ValueParts","values: any[]","value: string","node: INode","parent: Node","defaultRules: AssignmentRule[]","defaultComponents: ComponentRegistry","components: Record<string, any>","rules: AssignmentRule[]","h","component: T","props: MaybeFunctionProps<ComponentProps<T>>","components: Record<string, ValidComponent>","components","fn: T","props: TProps"],"sources":["../src/util.ts","../src/assign.ts","../src/html.ts","../src/defaults.ts","../src/h.ts"],"sourcesContent":["import { SVGElements } from \"solid-js/web\";\nimport { MaybeFunction } from \"./types\";\n\nexport function isString(value: any): value is string {\n  return typeof value === \"string\";\n}\n\nexport function isFunction(value: any): value is Function {\n  return typeof value === \"function\";\n}\n\nexport function isArray(value: any): value is any[] {\n  return Array.isArray(value);\n}\n\nexport const toArray = Array.from;\n\n\nexport const doc = document\n\nexport const createComment = (data:string)=>doc.createComment(data)\n\nexport function createElement(tag: string){\n  return SVGElements.has(tag) ? doc.createElementNS(\"http://www.w3.org/2000/svg\", tag) : doc.createElement(tag)\n}","import {\n  addEventListener,\n  DelegatedEvents,\n  delegateEvents,\n  effect,\n  insert,\n} from \"solid-js/web\";\nimport { isFunction, isString } from \"./util\";\nimport { AssignmentRule } from \"./types\";\n\n\n\n\nexport function assignEvent(\n  node: Element,\n  name: string,\n  value: any,\n  prev?: any\n) {\n  prev && node.removeEventListener(name, prev);\n  value && node.addEventListener(name, value);\n  return value;\n}\n\nexport function assignDelegatedEvent(\n  node: Element,\n  name: string,\n  value: any,\n  prev?: any\n) {\n  name = name.toLowerCase()\n  let delegate = DelegatedEvents.has(name);\n  addEventListener(node, name, value, delegate);\n  if (delegate) delegateEvents([name]);\n  return value;\n}\n\nexport function assignProperty(\n  node: Element,\n  name: string,\n  value: any,\n  prev?: any\n) {\n  (node as any)[name] = value;\n  return value;\n}\n\nexport function assignBooleanAttribute(\n  node: Element,\n  name: string,\n  value: any,\n  prev?: any\n) {\n  if (value) {\n    node.setAttribute(name, \"\");\n  } else {\n    node.removeAttribute(name);\n  }\n  return value;\n}\n\nexport function assignAttribute(\n  node: Element,\n  name: string,\n  value: any,\n  prev?: any\n) {\n  if (value === null || value === undefined) {\n    node.removeAttribute(name);\n    return value;\n  }\n  node.setAttribute(name, value);\n  return value;\n}\n\nexport function assignAttributeNS(\n  namespace: string,\n  node: Element,\n  name: string,\n  value: any,\n  prev?: any,\n) {\n  if (value === null || value === undefined) {\n    node.removeAttributeNS(namespace, name);\n    return value;\n  }\n  node.setAttributeNS(namespace, name, value);\n  return value;\n}\n\nexport function assignClass(\n  node: Element,\n  name: string,\n  value: any,\n  prev?: any\n) {\n  node.classList.toggle(name, !!value);\n  return value;\n}\n\nexport function assignStyle(\n  node: Element,\n  name: string,\n  value: any,\n  prev?: any\n) {\n  (node as HTMLElement).style[name as any] = value ? value : \"\";\n  return value;\n}\n\n\nexport function assignRef(node: Element, name: string, value: any, prev?: any) {\n  if (isFunction(value)) {\n    value(node);\n  }\n}\n\nexport function assign(\n  rules: AssignmentRule[],\n  elem: Element,\n  name: string,\n  value: any,\n  prev?: any\n) {\n  if (value === prev) return value;\n  if (name === \"children\") {\n    return insert(elem, value);\n  }\n\n  for (const rule of rules) {\n    const { filter, assign, isReactive = true } = rule;\n    if (isString(filter) && name.startsWith(filter)) {\n      name = name.slice(filter.length);\n    } else if (isFunction(filter)) {\n      name = filter(elem, name, value, prev);\n    } else {\n      continue;\n    }\n    if (name) {\n      if (isFunction(value) && isReactive) {\n        effect(() => (prev = assign(elem, name, value(), prev)));\n      } else {\n        assign(elem, name, value, prev);\n      }\n      return prev;\n    }\n  }\n}\n\n\n\nexport function spread(\n  rules: AssignmentRule[],\n  elem: Element,\n  props: any,\n  prev: any = {}\n) {\n\n  if (isFunction(props)) {\n    effect(() => {\n      for (const [name, value] of Object.entries(props())) {\n        prev[name] = assign(rules, elem, name, value, prev[name]);\n      }\n    });\n  } else {\n    for (const [name, value] of Object.entries(props)) {\n      prev[name] = assign(rules, elem, name, value, prev[name]);\n    }\n  }\n  return prev;\n}\n\n","import { INode, IText, SyntaxKind, parse } from \"html5parser\";\nimport { insert, setAttribute } from \"solid-js/web\";\nimport { assign } from \"./assign\";\nimport { H } from \"./h\";\nimport { AssignmentRule, ComponentRegistry } from \"./types\";\nimport { createComment, doc, isFunction, isString, toArray, createElement } from \"./util\";\n\ntype TreeNode = TextNode | ComponentNode | ElementNode | InsertNode | CommentNode\n\ntype ValueParts = Array<string | number>\n\ntype Property = [name: string, value: ValueParts]\n\n\nconst TEXT_NODE = 1\ntype TextNode = {\n  type: 1\n  value: string\n}\n\nconst COMMENT_NODE = 2\ntype CommentNode = {\n  type: 2\n  value: string\n}\n\nconst INSERT_NODE = 3\ntype InsertNode = {\n  type: 3\n  value: number\n}\n\nconst COMPONENT_NODE = 4\ntype ComponentNode = {\n  type: 4\n  name: string\n  props: Property[]\n  children: TreeNode[]\n  template?: HTMLTemplateElement\n}\n\nconst ELEMENT_NODE = 5\ntype ElementNode = {\n  type: 5\n  name: string\n  props: Property[]\n  children: TreeNode[],\n}\n\ntype RootNode = {\n  children: TreeNode[]\n  template?: HTMLTemplateElement\n}\n\n//Should be unique character that would never be in the template literal\nconst marker = '⧙⧘';\n\n\n\n//Captures index of hole\nconst match = new RegExp(`${marker}(\\\\d+)${marker}`, \"g\")\n\nconst cache = new WeakMap<TemplateStringsArray, RootNode>();\nconst walker = doc.createTreeWalker(doc, 133);\n\n\nfunction getCachedRoot(strings: TemplateStringsArray): RootNode {\n  let root = cache.get(strings);\n  if (!root) {\n    //join string with markers and index    \n    const ast = parse(strings.slice(1).reduce((prev, current, index) => prev + marker + index + marker + current, strings[0]))\n    const children = ast.flatMap(n => parseNode(n))\n\n    const template = buildTemplate(children)\n    root = {\n      children,\n      template\n    }\n\n    cache.set(strings, root);\n  }\n  return root;\n}\n\nfunction flat(arr: any[]) {\n  return (arr.length === 1 ? arr[0] : arr);\n}\n\nfunction getValue(value: any) {\n  while (isFunction(value)) value = value();\n  return value;\n}\n\n\nexport function HTML(components: ComponentRegistry = {}, rules: AssignmentRule[] = []) {\n  function html(strings: TemplateStringsArray, ...values: any[]) {\n    const cached = getCachedRoot(strings);\n\n    function renderTemplate(template: HTMLTemplateElement, componentNode: ComponentNode | RootNode) {\n      const clone = template.content.cloneNode(true)\n      walker.currentNode = clone;\n      walkNodes(componentNode.children)\n\n      function walkNodes(nodes: TreeNode[]) {\n        for (const node of nodes) {\n          const domNode = walker.nextNode()!;\n          if (node.type === ELEMENT_NODE) {\n            for (const [name, parts] of node.props) {\n              // If static props appplied template, they can be skipped here\n              // if (parts.length===1 && isString(parts[0])) continue\n              const value = substituteValues(parts, values);\n              assign(html.h.rules, domNode as Element, name, value.length === 1 ? value[0] : () => value.map(getValue).join(\"\"))\n            }\n            walkNodes(node.children)\n          } else if (node.type === INSERT_NODE || node.type === COMPONENT_NODE) {\n            insert(domNode.parentNode!, renderNode(node), domNode)\n            walker.currentNode = domNode\n          }\n        }\n      }\n      return toArray(clone.childNodes)\n    }\n\n    function renderNode(node: TreeNode): any {\n      switch (node.type) {\n        case TEXT_NODE:\n          return node.value;\n        case INSERT_NODE:\n          return values[node.value];\n        case COMMENT_NODE:\n          return createComment(node.value);\n      }\n      const template = node.type === COMPONENT_NODE && node.template\n\n      // gather props\n      const props = {} as Record<string, any>;\n      for (let [name, parts] of node.props) {\n        const value = substituteValues(parts, values);\n        props[name] = value.length === 1 ? value[0] : () => value.map(getValue)\n      }\n\n      // children - childNodes overwrites any props.children\n      if (node.children.length) {\n        props.children = template ? () => renderTemplate(template, node) : () => flat(node.children.map(renderNode))\n      }\n\n      return html.h(node.name, props);\n    }\n\n    return cached.template ? renderTemplate(cached.template, cached) : flat(cached.children.map(renderNode));\n  }\n\n  html.h = H(components, rules);\n\n  return html;\n}\n\n\n\n\nfunction substituteValues(parts: ValueParts, values: any[]) {\n  return parts.map(v => isString(v) ? v : values[v])\n}\n\n//Split by marker and extract index of hole. Remove empty strings \nfunction parseValue(value: string = \"\"): ValueParts {\n  return value.split(match).map((v, i) => (i % 2 === 1 ? Number(v) : v)).filter(v => !isString(v) || v.trim())\n}\n\n\n//Parse html5parser result for what we care about\nfunction parseNode(node: INode): TreeNode | TreeNode[] {\n\n  //Text nodes are either static text or holes to insert in\n  if (node.type === SyntaxKind.Text) {\n    const parts = parseValue(node.value)\n    return parts.map(value => {\n      const type = isString(value) ? TEXT_NODE : INSERT_NODE\n      return {\n        type,\n        value,\n      } as InsertNode | TextNode\n    })\n  }\n\n\n  if (node.name[0] === \"!\" || node.name === \"\") {\n    return {\n      type: COMMENT_NODE,\n      value: (node.body as IText[])[0].value\n    } as CommentNode\n  }\n\n  const props = node.attributes.map(v => [v.name.value, parseValue(v.value?.value)]) as Property[]\n  const children = node.body?.flatMap((n) => parseNode(n)) ?? []\n\n  if (/^[A-Z]/.test(node.rawName)) {\n    return {\n      type: COMPONENT_NODE,\n      name: node.rawName,\n      props,\n      children,\n      template: buildTemplate(children)\n    } as ComponentNode\n  }\n\n  return {\n    type: ELEMENT_NODE,\n    name: node.name,\n    props,\n    children,\n  } as ElementNode\n}\n\n\n//build template element with same exact shape as tree so they can be walked through in sync\nfunction buildTemplate(nodes: TreeNode[]): HTMLTemplateElement | undefined {\n  //Criteria for using template is component or root has at least 1 element. May be be a more optimal condition.\n  if (nodes.some((v) => v.type === ELEMENT_NODE)) {\n    const template = doc.createElement(\"template\")\n    buildNodes(nodes, template.content)\n    return template\n  }\n}\n\n\nfunction buildNodes(nodes: TreeNode[], parent: Node,) {\n  for (const node of nodes) {\n    switch (node.type) {\n      case TEXT_NODE:\n        parent.appendChild(doc.createTextNode(node.value));\n        break;\n      case COMMENT_NODE:\n        parent.appendChild(createComment(node.value));\n        break;\n      case INSERT_NODE:\n        parent.appendChild(createComment('+'));\n        break;\n      case COMPONENT_NODE:\n        parent.appendChild(createComment(node.name));\n        break;\n      case ELEMENT_NODE:\n        const elem = createElement(node.name);\n        parent.appendChild(elem);\n        //Apply static properties here?\n        buildNodes(node.children, elem);\n        break;\n    }\n  }\n}\n","import {\n  Dynamic,\n  ErrorBoundary,\n  For,\n  Index,\n  Match,\n  NoHydration,\n  Portal,\n  Show,\n  Suspense,\n  Switch,\n} from \"solid-js/web\";\nimport {\n  assignAttribute,\n  assignBooleanAttribute,\n  assignClass,\n  assignDelegatedEvent,\n  assignEvent,\n  assignProperty,\n  assignRef,\n  assignStyle\n} from \"./assign\";\nimport { H } from \"./h\";\nimport { HTML } from \"./html\";\nimport { AssignmentRule, ComponentRegistry } from \"./types\";\n\n\n\nexport const defaultRules: AssignmentRule[] = [\n  { filter: \"on:\", assign: assignEvent, isReactive: false },\n  { filter: \"on\", assign: assignDelegatedEvent, isReactive: false },\n  { filter: \"prop:\", assign: assignProperty },\n  { filter: \"bool:\", assign: assignBooleanAttribute },\n  { filter: \"attr:\", assign: assignAttribute },\n  { filter: \"ref:\", assign: assignRef, isReactive: false },\n  { filter: \"class:\", assign: assignClass },\n  { filter: \"style:\", assign: assignStyle },\n  { filter: \"@\", assign: assignDelegatedEvent, isReactive: false },\n  { filter: \".\", assign: assignProperty },\n  { filter: \"?\", assign: assignBooleanAttribute },\n  { filter: \"\", assign: assignAttribute } //default\n]\n\n\n\nexport const defaultComponents: ComponentRegistry = {\n  For,\n  Index,\n  Match,\n  Suspense,\n  ErrorBoundary,\n  Show,\n  Switch,\n  Dynamic,\n  Portal,\n  NoHydration,\n}\n\n\nexport const h = H();\n\nexport const html = HTML()\n//link global xml with global h\nhtml.h = h\n\n","import {\n  createComponent,\n  type ComponentProps,\n  type JSX,\n  type ValidComponent,\n} from \"solid-js\";\n\nimport { spread } from \"./assign\";\nimport { defaultComponents, defaultRules } from \"./defaults\";\n\nimport { createElement, doc, isFunction, isString } from \"./util\";\nimport { SVGElements } from \"solid-js/web\";\nimport { AssignmentRule, MaybeFunctionProps } from \"./types\";\n\nexport function H(components: Record<string, any> = {}, rules: AssignmentRule[] = []) {\n\n  function h<T extends ValidComponent>(\n    component: T,\n    props: MaybeFunctionProps<ComponentProps<T>>,\n    ...children: JSX.Element[]\n  ): JSX.Element {\n    //children in spread syntax override children in props\n    if (children.length === 1) {\n      //@ts-expect-error\n      props.children = children[0];\n    } else if (children.length > 1) {\n      //@ts-expect-error\n      props.children = children;\n    }\n\n    if (isFunction(component)) {\n      return createComponent(component, wrapProps(props));\n    }\n\n    if (isString(component)) {\n      const componentFunction = (h.components)[component];\n      if (componentFunction) {\n        return createComponent(componentFunction, wrapProps(props));\n      }\n      \n      if (/^[A-Z]/.test(component)) {\n        console.warn(`Forgot to define ${componentFunction}`);\n      }\n\n      const elem = createElement(component)\n      spread(h.rules, elem, props);\n      return elem;\n    } \n  }\n  \n  h.components = {...defaultComponents, ...components};\n  h.define = (components: Record<string, ValidComponent>) => {\n    Object.assign(h.components, components);\n  };\n  h.rules = [...rules, ...defaultRules];\n\n\n  return h;\n\n}\n\n\n\n\nexport const markedOnce = new WeakSet();\n\n/**\n * Marks a function so it is not wrapped as a getter by h().\n * Useful for event handlers or functions that should not be auto-accessed.\n * @example\n * once(() => doSomething())\n */\nexport function once<T extends (...args: any[]) => any>(fn: T): T {\n  if (isFunction(fn)) markedOnce.add(fn);\n  return fn;\n}\n\n/**\n * Internal: Replaces accessor props with getters for reactivity, except for refs and event handlers.\n */\nexport function wrapProps<\n  TComponent extends ValidComponent,\n  TProps extends MaybeFunctionProps<ComponentProps<TComponent>>\n>(props: TProps = {} as TProps): ComponentProps<TComponent> {\n  for (const [key, {value}] of Object.entries(\n    Object.getOwnPropertyDescriptors(props)\n  )) {\n    if (isFunction(value) && value.length === 0 && !markedOnce.has(value)) {\n      Object.defineProperty(props, key, {\n        get() {\n          return value();\n        },\n        enumerable: true,\n      });\n    }\n  }\n  return props as ComponentProps<TComponent>;\n}\n"],"mappings":"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"}