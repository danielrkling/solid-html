{"version":3,"file":"index.mjs","names":["value: MaybeFunction<T>","when: () => T","children: (item: Accessor<NonNullable<T>>)=>JSX.Element","fallback?: ()=>JSX.Element","_Show","children: ((item: NonNullable<T>) => JSX.Element)","children: ()=>JSX.Element[]","fallback: ()=>JSX.Element","_Switch","children: ((item: Accessor<NonNullable<T>>) => JSX.Element)","_Match","each: () => T | false | null | undefined","children: (item: T[number], index: () => number) => JSX.Element","_For","children: (item: () => T[number], index: number) => JSX.Element","_Index","children: ()=>JSX.Element","_Suspense","fallback: ((err: any, reset: () => void) => JSX.Element)","_ErrorBoundary","context: _Context<T>","value: T","children: () => JSX.Element","value: any","node: Element","name: string","value: any","prev?: any","namespace: string","rules: AssignmentRule[]","elem: Element","assign","props: any","prev: any","strings: TemplateStringsArray","type: ResultType","attrNames: Array<string>","html","rawTextEndRegex: RegExp | undefined","attrName: string | undefined","match!: RegExpExecArray | null","match","end","htmlResult: string","strings: TemplateStringsArray","type: ResultType","html","rules: AssignmentRule[]","value: any","strings","strings: TemplateStringsArray","xmlns: string[]","xml","arr: any","getValue","value: any","values: any[]","value: string | null","components: ComponentRegistry","rules: AssignmentRule[]","template: TemplateStringsArray","node: Node","defaultRules: AssignmentRule[]","defaultComponents: ComponentRegistry","components: Record<string, any>","rules: AssignmentRule[]","h","component: T","props: MaybeFunctionProps<ComponentProps<T>>","components: Record<string, ValidComponent>","components","fn: T","props: TProps"],"sources":["../src/components.ts","../src/util.ts","../src/assign.ts","../src/lit-html.ts","../src/html.ts","../src/xml.ts","../src/defaults.ts","../src/h.ts"],"sourcesContent":["import {\r\n  type Context as _Context,\r\n  ErrorBoundary as _ErrorBoundary,\r\n  For as _For,\r\n  Index as _Index,\r\n  Match as _Match,\r\n  Show as _Show,\r\n  Suspense as _Suspense,\r\n  Switch as _Switch,\r\n  createComponent,\r\n  JSX,\r\n  Accessor,\r\n} from \"solid-js\";\r\nimport { MaybeFunction } from \"./types\";\r\n\r\nexport function getValue<T>(value: MaybeFunction<T>): T {\r\n  if (typeof value === \"function\") {\r\n    //@ts-expect-error\r\n    return value();\r\n  }else{\r\n    return value;\r\n  }\r\n}\r\n\r\n/**\r\n * Solid-compatible Show component. Renders children if `when` is truthy, otherwise renders `fallback`.\r\n * @example\r\n * Show(() => isVisible(), html`<span>Hello</span>`, \"Fallback\")\r\n */\r\nexport function Show<T>(\r\n  when: () => T,\r\n  children: (item: Accessor<NonNullable<T>>)=>JSX.Element,\r\n  fallback?: ()=>JSX.Element\r\n): JSX.Element {\r\n  return createComponent(_Show, {\r\n    get when() {\r\n      return when();\r\n    },\r\n    //@ts-expect-error\r\n    children,\r\n    get fallback(){\r\n      return fallback?.()\r\n    },\r\n    //@ts-expect-error\r\n    keyed: false,\r\n  });\r\n}\r\n\r\n\r\n\r\n/**\r\n * Show component with keyed mode. Renders children with keyed context if `when` is truthy.\r\n * @example\r\n * ShowKeyed(() => user(), user => html`<span>${user.name}</span>`, \"No user\")\r\n */\r\nexport function ShowKeyed<T>(\r\n  when: () => T,\r\n  children: ((item: NonNullable<T>) => JSX.Element),\r\n  fallback?: ()=>JSX.Element\r\n): JSX.Element {\r\n  return createComponent(_Show, {\r\n    get when() {\r\n      return when();\r\n    },\r\n    //@ts-expect-error\r\n    children,\r\n    get fallback(){\r\n      return fallback?.()\r\n    },\r\n    keyed: true,\r\n  });\r\n}\r\n\r\n/**\r\n * Switch component for conditional rendering. Renders the first matching child, or `fallback` if none match.\r\n * @example\r\n * Switch(\"No match\", Match(() => cond1(), html`A`), Match(() => cond2(), html`B`))\r\n */\r\nexport function Switch(\r\n  children: ()=>JSX.Element[],\r\n  fallback: ()=>JSX.Element,  \r\n): JSX.Element {\r\n  return createComponent(_Switch, {\r\n    get fallback() {\r\n      return fallback();\r\n    },\r\n    get children(){\r\n      return children()\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Match component for use inside Switch. Renders children if `when` is truthy.\r\n * @example\r\n * Match(() => value() === 1, html`One`)\r\n */\r\nexport function Match<T>(\r\n  when: () => T,\r\n  children: ((item: Accessor<NonNullable<T>>) => JSX.Element)\r\n): JSX.Element {\r\n  return createComponent(_Match, {\r\n    get when() {\r\n      return when();\r\n    },\r\n    //@ts-expect-error\r\n    children,\r\n  });\r\n}\r\n\r\n/**\r\n * Keyed Match component for use inside Switch. Renders children with keyed context if `when` is truthy.\r\n * @example\r\n * MatchKeyed(() => user(), user => html`<span>${user.name}</span>`)\r\n */\r\nexport function MatchKeyed<T>(\r\n  when: () => T,\r\n  children: ((item: NonNullable<T>) => JSX.Element)\r\n): JSX.Element {\r\n  return createComponent(_Match, {\r\n    get when() {\r\n      return when();\r\n    },\r\n    //@ts-expect-error\r\n    children,\r\n    keyed: true\r\n  });\r\n}\r\n\r\n/**\r\n * For component for iterating over arrays. Renders children for each item in `each`.\r\n * @example\r\n * For(() => items(), (item) => html`<li>${item}</li>`)\r\n */\r\nexport function For<T extends readonly any[]>(\r\n  each: () => T | false | null | undefined,\r\n  children: (item: T[number], index: () => number) => JSX.Element,\r\n  fallback?: ()=>JSX.Element\r\n): JSX.Element {\r\n  return createComponent(_For, {\r\n    get each() {\r\n      return each();\r\n    },\r\n    children,\r\n    get fallback() {\r\n      return fallback?.();\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Index component for iterating over arrays by index. Renders children for each item in `each`.\r\n * @example\r\n * Index(() => items(), (item, i) => html`<li>${item()}</li>`)\r\n */\r\nexport function Index<T extends readonly any[]>(\r\n  each: () => T | false | null | undefined,\r\n  children: (item: () => T[number], index: number) => JSX.Element,\r\n  fallback?: ()=>JSX.Element\r\n): JSX.Element {\r\n  return createComponent(_Index, {\r\n    get each() {\r\n      return each();\r\n    },\r\n    children,\r\n    get fallback() {\r\n      return fallback?.()\r\n    }\r\n  });\r\n}\r\n\r\n/**\r\n * Suspense component for async boundaries. Renders `children` or `fallback` while loading.\r\n * @example\r\n * Suspense(html`<div>Loaded</div>`, html`<div>Loading...</div>`)\r\n */\r\nexport function Suspense(\r\n  children: ()=>JSX.Element,\r\n  fallback?: ()=>JSX.Element\r\n): JSX.Element {\r\n  return createComponent(_Suspense, {\r\n    get children() {\r\n      return children()\r\n    },\r\n    get fallback() {\r\n      return fallback?.()\r\n    },\r\n  });\r\n}\r\n\r\n/**\r\n * ErrorBoundary component. Catches errors in children and renders `fallback` on error.\r\n * @example\r\n * ErrorBoundary(html`<App />`, (err) => html`<div>Error: ${err.message}</div>`)\r\n */\r\nexport function ErrorBoundary(\r\n  children: ()=>JSX.Element,\r\n  fallback: ((err: any, reset: () => void) => JSX.Element)\r\n): JSX.Element {\r\n  return createComponent(_ErrorBoundary, {\r\n    get children() {\r\n      return children()\r\n    },\r\n    fallback\r\n  });\r\n}\r\n\r\n/**\r\n * Context provider component. Provides a context value to all children.\r\n * @example\r\n * Context(MyContext, value, () => html`<Child />`)\r\n */\r\nexport function Context<T>(\r\n  context: _Context<T>,\r\n  value: T,\r\n  children: () => JSX.Element\r\n): JSX.Element {\r\n  return createComponent(context.Provider, {\r\n    get children() {\r\n      return children()\r\n    },\r\n    value\r\n  });\r\n}\r\n","import { MaybeFunction } from \"./types\";\r\n\r\nexport function isString(value: any): value is string {\r\n  return typeof value === \"string\";\r\n}\r\n\r\nexport function isFunction(value: any): value is Function {\r\n  return typeof value === \"function\";\r\n}\r\n\r\nexport function isArray(value: any): value is any[] {\r\n  return Array.isArray(value);\r\n}\r\n\r\nexport const toArray = Array.from;\r\n\r\n\r\nexport const doc = document\r\n\r\n","import {\r\n  addEventListener,\r\n  DelegatedEvents,\r\n  delegateEvents,\r\n  effect,\r\n  insert,\r\n} from \"solid-js/web\";\r\nimport { isFunction, isString } from \"./util\";\r\nimport { AssignmentRule } from \"./types\";\r\n\r\n\r\n\r\n\r\nexport function assignEvent(\r\n  node: Element,\r\n  name: string,\r\n  value: any,\r\n  prev?: any\r\n) {\r\n  prev && node.removeEventListener(name, prev);\r\n  value && node.addEventListener(name, value);\r\n  return value;\r\n}\r\n\r\nexport function assignDelegatedEvent(\r\n  node: Element,\r\n  name: string,\r\n  value: any,\r\n  prev?: any\r\n) {\r\n  name = name.toLowerCase()\r\n  let delegate = DelegatedEvents.has(name);\r\n  addEventListener(node, name, value, delegate);\r\n  if (delegate) delegateEvents([name]);\r\n  return value;\r\n}\r\n\r\nexport function assignProperty(\r\n  node: Element,\r\n  name: string,\r\n  value: any,\r\n  prev?: any\r\n) {\r\n  (node as any)[name] = value;\r\n  return value;\r\n}\r\n\r\nexport function assignBooleanAttribute(\r\n  node: Element,\r\n  name: string,\r\n  value: any,\r\n  prev?: any\r\n) {\r\n  if (value) {\r\n    node.setAttribute(name, \"\");\r\n  } else {\r\n    node.removeAttribute(name);\r\n  }\r\n  return value;\r\n}\r\n\r\nexport function assignAttribute(\r\n  node: Element,\r\n  name: string,\r\n  value: any,\r\n  prev?: any\r\n) {\r\n  if (value === null || value === undefined) {\r\n    node.removeAttribute(name);\r\n    return value;\r\n  }\r\n  node.setAttribute(name, value);\r\n  return value;\r\n}\r\n\r\nexport function assignAttributeNS(\r\n  namespace: string,\r\n  node: Element,\r\n  name: string,\r\n  value: any,\r\n  prev?: any,\r\n) {\r\n  if (value === null || value === undefined) {\r\n    node.removeAttributeNS(namespace, name);\r\n    return value;\r\n  }\r\n  node.setAttributeNS(namespace, name, value);\r\n  return value;\r\n}\r\n\r\nexport function assignClass(\r\n  node: Element,\r\n  name: string,\r\n  value: any,\r\n  prev?: any\r\n) {\r\n  node.classList.toggle(name, !!value);\r\n  return value;\r\n}\r\n\r\nexport function assignStyle(\r\n  node: Element,\r\n  name: string,\r\n  value: any,\r\n  prev?: any\r\n) {\r\n  (node as HTMLElement).style[name as any] = value ? value : \"\";\r\n  return value;\r\n}\r\n\r\n\r\nexport function assignRef(node: Element, name: string, value: any, prev?: any) {\r\n  if (isFunction(value)) {\r\n    value(node);\r\n  }\r\n}\r\n\r\nexport function assign(\r\n  rules: AssignmentRule[],\r\n  elem: Element,\r\n  name: string,\r\n  value: any,\r\n  prev?: any\r\n) {\r\n  if (value === prev) return value;\r\n  if (name === \"children\") {\r\n    return insert(elem, value);\r\n  }\r\n\r\n  for (const rule of rules) {\r\n    const { filter, assign, isReactive = true } = rule;\r\n    if (isString(filter) && name.startsWith(filter)) {\r\n      name = name.slice(filter.length);\r\n    } else if (isFunction(filter)) {\r\n      name = filter(elem, name, value, prev);\r\n    } else {\r\n      continue;\r\n    }\r\n    if (name) {\r\n      if (isFunction(value) && isReactive) {\r\n        effect(() => (prev = assign(elem, name, value(), prev)));\r\n      } else {\r\n        assign(elem, name, value, prev);\r\n      }\r\n      return prev;\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\nexport function spread(\r\n  rules: AssignmentRule[],\r\n  elem: Element,\r\n  props: any,\r\n  prev: any = {}\r\n) {\r\n\r\n  if (isFunction(props)) {\r\n    effect(() => {\r\n      for (const [name, value] of Object.entries(props())) {\r\n        prev[name] = assign(rules, elem, name, value, prev[name]);\r\n      }\r\n    });\r\n  } else {\r\n    for (const [name, value] of Object.entries(props)) {\r\n      prev[name] = assign(rules, elem, name, value, prev[name]);\r\n    }\r\n  }\r\n  return prev;\r\n}\r\n\r\n","// Added to an attribute name to mark the attribute as bound so we can find\r\n// it easily.\r\nexport const boundAttributeSuffix = \"$lit$\";\r\n\r\n// This marker is used in many syntactic positions in HTML, so it must be\r\n// a valid element name and attribute name. We don't support dynamic names (yet)\r\n// but this at least ensures that the parse tree is closer to the template\r\n// intention.\r\nexport const marker = `lit$marker$`;\r\n\r\n// String used to tell if a comment is a marker comment\r\nexport const markerMatch = \"?\" + marker;\r\n\r\n// Text used to insert a comment marker node. We use processing instruction\r\n// syntax because it's slightly smaller, but parses as a comment node.\r\nexport const nodeMarker = `<${markerMatch}>`;\r\n\r\n\r\nconst SPACE_CHAR = `[ \\t\\n\\f\\r]`;\r\nconst ATTR_VALUE_CHAR = `[^ \\t\\n\\f\\r\"'\\`<>=]`;\r\nconst NAME_CHAR = `[^\\\\s\"'>=/]`;\r\n\r\n// These regexes represent the five parsing states that we care about in the\r\n// Template's HTML scanner. They match the *end* of the state they're named\r\n// after.\r\n// Depending on the match, we transition to a new state. If there's no match,\r\n// we stay in the same state.\r\n// Note that the regexes are stateful. We utilize lastIndex and sync it\r\n// across the multiple regexes used. In addition to the five regexes below\r\n// we also dynamically create a regex to find the matching end tags for raw\r\n// text elements.\r\n\r\n/**\r\n * End of text is: `<` followed by:\r\n *   (comment start) or (tag) or (dynamic tag binding)\r\n */\r\nconst textEndRegex = /<(?:(!--|\\/[^a-zA-Z])|(\\/?[a-zA-Z][^>\\s]*)|(\\/?$))/g;\r\nconst COMMENT_START = 1;\r\nconst TAG_NAME = 2;\r\nconst DYNAMIC_TAG_NAME = 3;\r\n\r\nconst commentEndRegex = /-->/g;\r\n/**\r\n * Comments not started with <!--, like </{, can be ended by a single `>`\r\n */\r\nconst comment2EndRegex = />/g;\r\n\r\n/**\r\n * The tagEnd regex matches the end of the \"inside an opening\" tag syntax\r\n * position. It either matches a `>`, an attribute-like sequence, or the end\r\n * of the string after a space (attribute-name position ending).\r\n *\r\n * See attributes in the HTML spec:\r\n * https://www.w3.org/TR/html5/syntax.html#elements-attributes\r\n *\r\n * \" \\t\\n\\f\\r\" are HTML space characters:\r\n * https://infra.spec.whatwg.org/#ascii-whitespace\r\n *\r\n * So an attribute is:\r\n *  * The name: any character except a whitespace character, (\"), ('), \">\",\r\n *    \"=\", or \"/\". Note: this is different from the HTML spec which also excludes control characters.\r\n *  * Followed by zero or more space characters\r\n *  * Followed by \"=\"\r\n *  * Followed by zero or more space characters\r\n *  * Followed by:\r\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\r\n *    * (\") then any non-(\"), or\r\n *    * (') then any non-(')\r\n */\r\nconst tagEndRegex = new RegExp(\r\n  `>|${SPACE_CHAR}(?:(${NAME_CHAR}+)(${SPACE_CHAR}*=${SPACE_CHAR}*(?:${ATTR_VALUE_CHAR}|(\"|')|))|$)`,\r\n  \"g\"\r\n);\r\nconst ENTIRE_MATCH = 0;\r\nconst ATTRIBUTE_NAME = 1;\r\nconst SPACES_AND_EQUALS = 2;\r\nconst QUOTE_CHAR = 3;\r\n\r\nconst singleQuoteAttrEndRegex = /'/g;\r\nconst doubleQuoteAttrEndRegex = /\"/g;\r\n/**\r\n * Matches the raw text elements.\r\n *\r\n * Comments are not parsed within raw text elements, so we need to search their\r\n * text content for marker strings.\r\n */\r\nconst rawTextElement = /^(?:script|style|textarea|title)$/i;\r\n\r\n/** TemplateResult types */\r\nexport const HTML_RESULT = 1;\r\nexport const SVG_RESULT = 2;\r\nexport const MATHML_RESULT = 3;\r\n\r\nexport type ResultType = typeof HTML_RESULT | typeof SVG_RESULT | typeof MATHML_RESULT;\r\n\r\n\r\n\r\n/**\r\n * Returns an HTML string for the given TemplateStringsArray and result type\r\n * (HTML or SVG), along with the case-sensitive bound attribute names in\r\n * template order. The HTML contains comment markers denoting the `ChildPart`s\r\n * and suffixes on bound attributes denoting the `AttributeParts`.\r\n *\r\n * @param strings template strings array\r\n * @param type HTML or SVG\r\n * @return Array containing `[html, attrNames]` (array returned for terseness,\r\n *     to avoid object fields since this code is shared with non-minified SSR\r\n *     code)\r\n */\r\nexport const getTemplateHtml = (\r\n  strings: TemplateStringsArray,\r\n  type: ResultType\r\n): [string, Array<string>] => {\r\n  // Insert makers into the template HTML to represent the position of\r\n  // bindings. The following code scans the template strings to determine the\r\n  // syntactic position of the bindings. They can be in text position, where\r\n  // we insert an HTML comment, attribute value position, where we insert a\r\n  // sentinel string and re-write the attribute name, or inside a tag where\r\n  // we insert the sentinel string.\r\n  const l = strings.length - 1;\r\n  // Stores the case-sensitive bound attribute names in the order of their\r\n  // parts. ElementParts are also reflected in this array as undefined\r\n  // rather than a string, to disambiguate from attribute bindings.\r\n  const attrNames: Array<string> = [];\r\n  let html =\r\n    type === SVG_RESULT ? \"<svg>\" : type === MATHML_RESULT ? \"<math>\" : \"\";\r\n\r\n  // When we're inside a raw text tag (not it's text content), the regex\r\n  // will still be tagRegex so we can find attributes, but will switch to\r\n  // this regex when the tag ends.\r\n  let rawTextEndRegex: RegExp | undefined;\r\n\r\n  // The current parsing state, represented as a reference to one of the\r\n  // regexes\r\n  let regex = textEndRegex;\r\n\r\n  for (let i = 0; i < l; i++) {\r\n    const s = strings[i];\r\n    // The index of the end of the last attribute name. When this is\r\n    // positive at end of a string, it means we're in an attribute value\r\n    // position and need to rewrite the attribute name.\r\n    // We also use a special value of -2 to indicate that we encountered\r\n    // the end of a string in attribute name position.\r\n    let attrNameEndIndex = -1;\r\n    let attrName: string | undefined;\r\n    let lastIndex = 0;\r\n    let match!: RegExpExecArray | null;\r\n\r\n    // The conditions in this loop handle the current parse state, and the\r\n    // assignments to the `regex` variable are the state transitions.\r\n    while (lastIndex < s.length) {\r\n      // Make sure we start searching from where we previously left off\r\n      regex.lastIndex = lastIndex;\r\n      match = regex.exec(s);\r\n      if (match === null) {\r\n        break;\r\n      }\r\n      lastIndex = regex.lastIndex;\r\n      if (regex === textEndRegex) {\r\n        if (match[COMMENT_START] === \"!--\") {\r\n          regex = commentEndRegex;\r\n        } else if (match[COMMENT_START] !== undefined) {\r\n          // We started a weird comment, like </{\r\n          regex = comment2EndRegex;\r\n        } else if (match[TAG_NAME] !== undefined) {\r\n          if (rawTextElement.test(match[TAG_NAME])) {\r\n            // Record if we encounter a raw-text element. We'll switch to\r\n            // this regex at the end of the tag.\r\n            rawTextEndRegex = new RegExp(`</${match[TAG_NAME]}`, \"g\");\r\n          }\r\n          regex = tagEndRegex;\r\n        } else if (match[DYNAMIC_TAG_NAME] !== undefined) {\r\n          regex = tagEndRegex;\r\n        }\r\n      } else if (regex === tagEndRegex) {\r\n        if (match[ENTIRE_MATCH] === \">\") {\r\n          // End of a tag. If we had started a raw-text element, use that\r\n          // regex\r\n          regex = rawTextEndRegex ?? textEndRegex;\r\n          // We may be ending an unquoted attribute value, so make sure we\r\n          // clear any pending attrNameEndIndex\r\n          attrNameEndIndex = -1;\r\n        } else if (match[ATTRIBUTE_NAME] === undefined) {\r\n          // Attribute name position\r\n          attrNameEndIndex = -2;\r\n        } else {\r\n          attrNameEndIndex = regex.lastIndex - match[SPACES_AND_EQUALS].length;\r\n          attrName = match[ATTRIBUTE_NAME];\r\n          regex =\r\n            match[QUOTE_CHAR] === undefined\r\n              ? tagEndRegex\r\n              : match[QUOTE_CHAR] === '\"'\r\n              ? doubleQuoteAttrEndRegex\r\n              : singleQuoteAttrEndRegex;\r\n        }\r\n      } else if (\r\n        regex === doubleQuoteAttrEndRegex ||\r\n        regex === singleQuoteAttrEndRegex\r\n      ) {\r\n        regex = tagEndRegex;\r\n      } else if (regex === commentEndRegex || regex === comment2EndRegex) {\r\n        regex = textEndRegex;\r\n      } else {\r\n        // Not one of the five state regexes, so it must be the dynamically\r\n        // created raw text regex and we're at the close of that element.\r\n        regex = tagEndRegex;\r\n        rawTextEndRegex = undefined;\r\n      }\r\n    }\r\n\r\n    // We have four cases:\r\n    //  1. We're in text position, and not in a raw text element\r\n    //     (regex === textEndRegex): insert a comment marker.\r\n    //  2. We have a non-negative attrNameEndIndex which means we need to\r\n    //     rewrite the attribute name to add a bound attribute suffix.\r\n    //  3. We're at the non-first binding in a multi-binding attribute, use a\r\n    //     plain marker.\r\n    //  4. We're somewhere else inside the tag. If we're in attribute name\r\n    //     position (attrNameEndIndex === -2), add a sequential suffix to\r\n    //     generate a unique attribute name.\r\n\r\n    // Detect a binding next to self-closing tag end and insert a space to\r\n    // separate the marker from the tag end:\r\n    const end =\r\n      regex === tagEndRegex && strings[i + 1].startsWith(\"/>\") ? \" \" : \"\";\r\n    html +=\r\n      regex === textEndRegex\r\n        ? s + nodeMarker\r\n        : attrNameEndIndex >= 0\r\n        ? (attrNames.push(attrName!),\r\n          s.slice(0, attrNameEndIndex) +\r\n            boundAttributeSuffix +\r\n            s.slice(attrNameEndIndex)) +\r\n          marker +\r\n          end\r\n        : s + marker + (attrNameEndIndex === -2 ? i : end);\r\n  }\r\n\r\n  const htmlResult: string =\r\n    html +\r\n    (strings[l] || \"<?>\") +\r\n    (type === SVG_RESULT ? \"</svg>\" : type === MATHML_RESULT ? \"</math>\" : \"\");\r\n\r\n  // Returned as an array for terseness\r\n  return [htmlResult, attrNames];\r\n};\r\n","import { type JSX } from \"solid-js\";\r\nimport {\r\n  effect,\r\n  insert,\r\n  SVGElements\r\n} from \"solid-js/web\";\r\n\r\nimport {\r\n  boundAttributeSuffix,\r\n  getTemplateHtml,\r\n  HTML_RESULT,\r\n  marker,\r\n  markerMatch,\r\n  MATHML_RESULT,\r\n  ResultType,\r\n  SVG_RESULT,\r\n} from \"./lit-html\";\r\nimport { doc, isFunction } from \"./util\";\r\nimport { AssignmentRule } from \"./types\";\r\nimport { assign, spread } from \"./assign\";\r\nimport { defaultRules } from \"./defaults\";\r\n\r\n\r\n\r\ntype Template = [element: HTMLTemplateElement, attributes: string[]];\r\n\r\nconst walker = doc.createTreeWalker(doc, 129);\r\n\r\nconst templateCache = new WeakMap<TemplateStringsArray, Template>();\r\n\r\n/**\r\n * Returns a parsed template and its bound attributes for a given template string and type.\r\n * @internal\r\n */\r\nfunction getTemplate(\r\n  strings: TemplateStringsArray,\r\n  type: ResultType\r\n): Template {\r\n  let template = templateCache.get(strings);\r\n  if (template === undefined) {\r\n    const [html, attributes] = getTemplateHtml(strings, type);\r\n    const element = doc.createElement(\"template\");\r\n    element.innerHTML = html;\r\n    template = [element, attributes];\r\n    templateCache.set(strings, template);\r\n  }\r\n  return template;\r\n}\r\n\r\n\r\n\r\n/**\r\n * Creates a tagged template function for html/svg/mathml templates with Solid reactivity.\r\n * @internal\r\n */\r\nexport function HTML(type: ResultType = 1, rules: AssignmentRule[] = []) {\r\n  function html(\r\n    strings: TemplateStringsArray,\r\n    ...values: any[]\r\n  ): JSX.Element {\r\n\r\n    const [element, attributes] = getTemplate(strings, type);\r\n    const clone = element.content.cloneNode(true);\r\n\r\n    let valueIndex = 0;\r\n    let boundAttributeIndex = 0;\r\n    walker.currentNode = clone;\r\n\r\n    while (walker.nextNode()) {\r\n      const node = walker.currentNode;\r\n      if (node.nodeType === 1) {\r\n        for (const attr of [...(node as Element).attributes]) {\r\n          if (attr.name.endsWith(boundAttributeSuffix)) {\r\n            //Bound attribute/prop/event\r\n            let value: any\r\n            if (attr.value === marker) {\r\n              value = values[valueIndex++];\r\n            } else {\r\n              const strings = attr.value.split(marker);\r\n              let parts = [strings[0]] as any[];\r\n              for (let j = 1; j < strings.length; j++) {\r\n                parts.push(values[valueIndex++], strings[j]);\r\n              }\r\n              value = () => parts.map((v) => (isFunction(v) ? v() : v)).join(\"\");\r\n\r\n            }\r\n            assign(html.rules, node as Element, attributes[boundAttributeIndex++], value);\r\n            (node as Element).removeAttribute(attr.name);\r\n          } else if (attr.name === `...${marker}`) {\r\n            //Spread\r\n            const isSvg = SVGElements.has((node as Element).tagName);\r\n            const value = values[valueIndex++];\r\n            if (isFunction(value)) {\r\n              effect(() => spread(html.rules, node as Element, value()));\r\n            } else {\r\n              spread(html.rules, node as Element, value);\r\n            }\r\n            (node as Element).removeAttribute(attr.name);\r\n          } else if (attr.name.startsWith(marker)) {\r\n            //Refs\r\n            const value = values[valueIndex++];\r\n            if (isFunction(value)) {\r\n              value(node as Element);\r\n            }\r\n            (node as Element).removeAttribute(attr.name);\r\n          }\r\n        }\r\n      } else if (node.nodeType === 8) {\r\n        if (node.nodeValue === markerMatch) {\r\n          node.nodeValue = marker + valueIndex; //I don't know why, but this prevents misplaced elements\r\n          const value = values[valueIndex++];\r\n          const parent = node.parentNode;\r\n          if (parent) insert(parent, value, node);\r\n        }\r\n      }\r\n    }\r\n    if (type === SVG_RESULT || type === MATHML_RESULT) {\r\n      return [...clone.firstChild!.childNodes];\r\n    }\r\n    return [...clone.childNodes];\r\n  }\r\n\r\n\r\n  html.rules = [...rules, ...defaultRules];\r\n\r\n  return html;\r\n}\r\n\r\n","import { xmlNamespaces } from \"./defaults\";\r\nimport { H } from \"./h\";\r\nimport { AssignmentRule, ComponentRegistry } from \"./types\";\r\nimport { doc, isFunction, toArray } from \"./util\";\r\n\r\nconst start = `$START$`\r\nconst end = `$END$`\r\nconst match = /\\$START\\$(\\d+)\\$END\\$/g\r\n\r\nconst xmlCache = new WeakMap<TemplateStringsArray, Node>();\r\n\r\n/**\r\n * Parses a template string as XML and returns the child nodes, using a cache for performance.\r\n * @internal\r\n */\r\nfunction getXml(strings: TemplateStringsArray, xmlns: string[]) {\r\n  let xml = xmlCache.get(strings);\r\n  if (xml === undefined) {\r\n    let contents = \"\", i = 0\r\n    const l = strings.length\r\n    //Join XML with index so proper value can be extracted later independent of when it's executed\r\n    for (i; i < l - 1; i++) {\r\n      const part = strings[i]\r\n      // Allows no quotes for single attribute. Causes edge case for =${} in text nodes or within attribute values. Can be fixed with ${'=' + var}\r\n      if (part.endsWith(\"=\")) {\r\n        contents += `${part}\"${start}${i}${end}\"`\r\n      } else {\r\n        contents += `${part}${start}${i}${end}`\r\n      }\r\n    }\r\n    contents += strings.at(-1)\r\n\r\n    const namespaces = xmlns\r\n      .map((ns) => `xmlns:${ns}=\"/\"`)\r\n      .join(\" \");\r\n\r\n    const parser = new DOMParser();\r\n    xml = parser.parseFromString(`<xml ${namespaces}>${contents}</xml>`, \"text/xml\")\r\n      .firstChild!;\r\n    xmlCache.set(strings, xml);\r\n  }\r\n  return xml.childNodes;\r\n}\r\n\r\nconst flat = (arr: any) => (arr.length === 1 ? arr[0] : arr);\r\nfunction getValue(value: any) {\r\n  while (isFunction(value)) value = value();\r\n  return value;\r\n}\r\n\r\nfunction extractValues(values: any[], value: string | null, convertMultiPartToString = false) {\r\n  if (value === null) return null\r\n  const matches = toArray(value.matchAll(match))\r\n  if (matches.length) {\r\n    if (matches[0][0] === matches[0].input.trim()) {\r\n      return values[Number(matches[0][1])];\r\n    } else {\r\n      let index = 0\r\n      const parts = value.split(match).map((x, i) => (i % 2 === 1 ? values[Number(matches[index++][1])] : x));\r\n      return convertMultiPartToString ? () => parts.map(getValue).join(\"\") : parts\r\n    }\r\n  }\r\n  return value\r\n}\r\n\r\nexport function XML(components: ComponentRegistry = {}, rules: AssignmentRule[] = [], xmlns: string[] = []) {\r\n  function xml(template: TemplateStringsArray, ...values: any[]) {\r\n    const cached = getXml(template, xml.xlmns);\r\n\r\n    function nodes(node: Node) {\r\n      if (node.nodeType === 1) {\r\n        // Element Node\r\n        const { tagName, childNodes, attributes } = (node as Element);\r\n\r\n        // gather props\r\n        const props = {} as Record<string, any>;\r\n        for (let { name, value } of attributes) {\r\n          props[name] = extractValues(values, value, true);\r\n        }\r\n\r\n        // children - childNodes overwrites any props.children\r\n        if (childNodes.length) {\r\n          props.children = () => flat(toArray(childNodes).map(nodes));\r\n        }\r\n\r\n        return xml.h(tagName, props);\r\n      } else if (node.nodeType === 3) {\r\n        // Text Node\r\n        return extractValues(values, node.nodeValue);\r\n      } else if (node.nodeType === 8) {\r\n        // Comment Node\r\n        return doc.createComment(extractValues(values, node.nodeValue, true));\r\n      } else {\r\n        console.error(`xml: nodeType not supported ${node.nodeType}`);\r\n      }\r\n    }\r\n\r\n    return flat(toArray(cached).map(nodes));\r\n  }\r\n\r\n  xml.xlmns = [...xmlNamespaces, ...xmlns]\r\n  xml.h = H(components, rules);\r\n\r\n  return xml;\r\n}\r\n","import {\r\n  Dynamic,\r\n  ErrorBoundary,\r\n  For,\r\n  Index,\r\n  Match,\r\n  NoHydration,\r\n  Portal,\r\n  Show,\r\n  Suspense,\r\n  Switch,\r\n} from \"solid-js/web\";\r\nimport {\r\n  assignAttribute,\r\n  assignBooleanAttribute,\r\n  assignClass,\r\n  assignDelegatedEvent,\r\n  assignEvent,\r\n  assignProperty,\r\n  assignRef,\r\n  assignStyle\r\n} from \"./assign\";\r\nimport { H } from \"./h\";\r\nimport { HTML } from \"./html\";\r\nimport { HTML_RESULT, MATHML_RESULT, SVG_RESULT } from \"./lit-html\";\r\nimport { AssignmentRule, ComponentRegistry } from \"./types\";\r\nimport { XML } from \"./xml\";\r\n\r\n\r\nexport const defaultRules: AssignmentRule[] = [\r\n  { filter: \"on:\", assign: assignEvent, isReactive: false },\r\n  { filter: \"on\", assign: assignDelegatedEvent, isReactive: false },\r\n  { filter: \"prop:\", assign: assignProperty },\r\n  { filter: \"bool:\", assign: assignBooleanAttribute },\r\n  { filter: \"attr:\", assign: assignAttribute },\r\n  { filter: \"ref:\", assign: assignRef, isReactive: false },\r\n  { filter: \"class:\", assign: assignClass },\r\n  { filter: \"style:\", assign: assignStyle },\r\n  { filter: \"@\", assign: assignDelegatedEvent, isReactive: false },\r\n  { filter: \".\", assign: assignProperty },\r\n  { filter: \"?\", assign: assignBooleanAttribute },\r\n  { filter: \"\", assign: assignAttribute } //default\r\n]\r\n\r\n\r\n\r\nexport const defaultComponents: ComponentRegistry = {\r\n  For,\r\n  Index,\r\n  Match,\r\n  Suspense,\r\n  ErrorBoundary,\r\n  Show,\r\n  Switch,\r\n  Dynamic,\r\n  Portal,\r\n  NoHydration,\r\n}\r\n\r\nexport const xmlNamespaces = [\"on\", \"prop\", \"bool\", \"attr\", \"ref\", \"style\", \"class\", \"xlink\"]\r\n\r\n\r\nexport const h = H();\r\n\r\nexport const xml = XML()\r\n//link global xml with global h\r\nxml.h = h\r\n\r\nexport const html = HTML(HTML_RESULT);\r\n\r\nexport const svg = HTML(SVG_RESULT);\r\n\r\nexport const mathml = HTML(MATHML_RESULT);\r\n","import {\r\n  createComponent,\r\n  type ComponentProps,\r\n  type JSX,\r\n  type ValidComponent,\r\n} from \"solid-js\";\r\n\r\nimport { spread } from \"./assign\";\r\nimport { defaultComponents, defaultRules } from \"./defaults\";\r\n\r\nimport { doc, isFunction, isString } from \"./util\";\r\nimport { SVGElements } from \"solid-js/web\";\r\nimport { AssignmentRule, MaybeFunctionProps } from \"./types\";\r\n\r\nexport function H(components: Record<string, any> = {}, rules: AssignmentRule[] = []) {\r\n\r\n  function h<T extends ValidComponent>(\r\n    component: T,\r\n    props: MaybeFunctionProps<ComponentProps<T>>,\r\n    ...children: JSX.Element[]\r\n  ): JSX.Element {\r\n    //children in spread syntax override children in props\r\n    if (children.length === 1) {\r\n      //@ts-expect-error\r\n      props.children = children[0];\r\n    } else if (children.length > 1) {\r\n      //@ts-expect-error\r\n      props.children = children;\r\n    }\r\n\r\n    if (isString(component)) {\r\n      const componentFunction = (h.components)[component];\r\n      if (componentFunction) {\r\n        return createComponent(componentFunction, wrapProps(props));\r\n      }\r\n      \r\n      if (/[A-Z]/.test(component)) {\r\n        console.warn(`Forgot to define ${componentFunction}`);\r\n      }\r\n\r\n      const elem = SVGElements.has(component) ? doc.createElementNS(\"http://www.w3.org/2000/svg\", component) : doc.createElement(component);\r\n      spread(h.rules, elem, props);\r\n      return elem;\r\n    } else if (isFunction(component)) {\r\n      return createComponent(component, wrapProps(props));\r\n    }\r\n  }\r\n  h.components = {...defaultComponents, ...components};\r\n  h.define = (components: Record<string, ValidComponent>) => {\r\n    Object.assign(h.components, components);\r\n  };\r\n  h.rules = [...rules, ...defaultRules];\r\n\r\n\r\n  return h;\r\n\r\n}\r\n\r\n\r\nexport const markedOnce = new WeakSet();\r\n\r\n/**\r\n * Marks a function so it is not wrapped as a getter by h().\r\n * Useful for event handlers or functions that should not be auto-accessed.\r\n * @example\r\n * once(() => doSomething())\r\n */\r\nexport function once<T extends (...args: any[]) => any>(fn: T): T {\r\n  if (isFunction(fn)) markedOnce.add(fn);\r\n  return fn;\r\n}\r\n\r\n/**\r\n * Internal: Replaces accessor props with getters for reactivity, except for refs and event handlers.\r\n */\r\nexport function wrapProps<\r\n  TComponent extends ValidComponent,\r\n  TProps extends MaybeFunctionProps<ComponentProps<TComponent>>\r\n>(props: TProps = {} as TProps): ComponentProps<TComponent> {\r\n  for (const [key, descriptor] of Object.entries(\r\n    Object.getOwnPropertyDescriptors(props)\r\n  )) {\r\n    const value = descriptor.value;\r\n    if (isFunction(value) && value.length === 0 && !markedOnce.has(value)) {\r\n      Object.defineProperty(props, key, {\r\n        get() {\r\n          return value();\r\n        },\r\n        enumerable: true,\r\n      });\r\n    }\r\n  }\r\n  return props as ComponentProps<TComponent>;\r\n}\r\n"],"mappings":"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"}