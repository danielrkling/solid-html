{"version":3,"file":"index.mjs","names":["value: any","data:string","tag: string","arr: any[]","input: TemplateStringsArray","html5parse","nodes: INode[]","node: INode","value: string","node: RootNode | ChildNode","node: ChildNode","components: T","sld","strings: TemplateStringsArray","newComponents: TNew","node: ChildNode","values: any[]","components: ComponentRegistry","node: ComponentNode | RootNode | ElementNode","nodes: ChildNode[]","node","node: ElementNode | ComponentNode","props: Record<string, any>","spread","component: T"],"sources":["../src/util.ts","../src/parse.ts","../src/template.ts","../src/sld.ts","../src/index.ts"],"sourcesContent":["import { SVGElements } from \"solid-js/web\";\r\n\r\n\r\nexport function isString(value: any): value is string {\r\n  return typeof value === \"string\";\r\n}\r\n\r\nexport function isNumber(value: any): value is number {\r\n  return typeof value === \"number\";\r\n}\r\n\r\nexport function isFunction(value: any): value is Function {\r\n  return typeof value === \"function\";\r\n}\r\n\r\nexport function isBoolean(value: any): value is boolean {\r\n  return typeof value === \"boolean\";\r\n}\r\n\r\nexport function isObject(value: any): value is object {\r\n  return typeof value === \"object\";\r\n}\r\n\r\nexport function isArray(value: any): value is any[] {\r\n  return Array.isArray(value);\r\n}\r\n\r\nexport const toArray = Array.from;\r\n\r\n\r\nexport const doc = document\r\n\r\nexport const createComment = (data:string)=>doc.createComment(data)\r\n\r\nexport function createElement(tag: string){\r\n  return SVGElements.has(tag) ? doc.createElementNS(\"http://www.w3.org/2000/svg\", tag) : doc.createElement(tag)\r\n}\r\n\r\nexport function flat(arr: any[]) {\r\n  return (arr.length === 1 ? arr[0] : arr);\r\n}\r\n\r\nexport function getValue(value: any) {\r\n  while (isFunction(value)) value = value();\r\n  return value;\r\n}","import {\r\n    SyntaxKind,\r\n    parse as html5parse,\r\n    type INode,\r\n    type IText\r\n} from \"html5parser\";\r\n\r\nimport { isNumber, isString } from \"./util\";\r\n\r\n\r\n//AST Node types\r\n\r\n//Non reactive text\r\nexport const TEXT_NODE = 1;\r\nexport type TextNode = {\r\n    type: typeof TEXT_NODE;\r\n    value: string;\r\n};\r\n\r\n//Non reactive Comment Node <!--value-->\r\nexport const COMMENT_NODE = 2;\r\nexport type CommentNode = {\r\n    type: typeof COMMENT_NODE;\r\n    value: string;\r\n};\r\n\r\n//Reactive Hole\r\nexport const INSERT_NODE = 3;\r\nexport type InsertNode = {\r\n    type: typeof INSERT_NODE;\r\n    value: number; //index of hole\r\n};\r\n\r\nexport const ELEMENT_NODE = 4;\r\nexport type ElementNode = {\r\n    type: typeof ELEMENT_NODE;\r\n    name: string;\r\n    props: Property[];\r\n    children: ChildNode[];\r\n};\r\n\r\nexport const COMPONENT_NODE = 5;\r\nexport type ComponentNode = {\r\n    type: typeof COMPONENT_NODE;\r\n    name: string;\r\n    props: Property[];\r\n    children: ChildNode[];\r\n    template?: HTMLTemplateElement\r\n};\r\n\r\nexport const ROOT_NODE = 6;\r\nexport type RootNode = {\r\n    type: typeof ROOT_NODE;\r\n    children: ChildNode[];\r\n    template?: HTMLTemplateElement\r\n};\r\n\r\nexport type ChildNode =\r\n    | TextNode\r\n    | ComponentNode\r\n    | ElementNode\r\n    | InsertNode\r\n    | CommentNode;\r\n\r\nexport type Property = [name: string, value: ValueParts];\r\n\r\n//string or boolean means static, number means hole and is index, array means mix of string and holes\r\nexport type ValueParts = string | boolean | number | Array<string | number>;\r\n\r\n//Needs to be unique character that would never be in the template literal\r\nconst marker = \"⧙⧘\";\r\n\r\n//Captures index of hole\r\nconst match = new RegExp(`${marker}(\\\\d+)${marker}`, \"g\");\r\n\r\n/**\r\n * \r\n * @param input jsx like string to parse\r\n * @returns RootNode of an AST\r\n */\r\nexport function parse(input: TemplateStringsArray): RootNode {\r\n    const ast = html5parse(\r\n        input\r\n            .slice(1)\r\n            .reduce(\r\n                (prev, current, index) => prev + marker + index + marker + current,\r\n                input[0],\r\n            ),\r\n    );\r\n    return {\r\n        type: ROOT_NODE,\r\n        children: parseNodes(ast)\r\n    }\r\n}\r\n\r\nfunction parseNodes(nodes: INode[]) {\r\n    return nodes.flatMap(parseNode)\r\n}\r\n//Parse html5parser result for what we care about\r\nfunction parseNode(\r\n    node: INode,\r\n): ChildNode | ChildNode[] {\r\n    //Text nodes are either static text or holes to insert in\r\n    if (node.type === SyntaxKind.Text) {\r\n        const parts = getParts(node.value);\r\n        return parts.map((value) => {\r\n            const type = isString(value) ? TEXT_NODE : INSERT_NODE;\r\n            return {\r\n                type,\r\n                value,\r\n            } as InsertNode | TextNode;\r\n        });\r\n    }\r\n\r\n    //html5parser represents comments as type tag with name \"!\" or \"\"\r\n    if (node.name[0] === \"!\" || node.name === \"\") {\r\n        return {\r\n            type: COMMENT_NODE,\r\n            value: (node.body as IText[]).reduce((p,v)=>p+=v.value,\"\"),\r\n        } as CommentNode;\r\n    }\r\n\r\n    const props = node.attributes.map((v) => {\r\n        const nameParts = getParts(v.name.value);\r\n\r\n        if (nameParts.length === 1) {\r\n            const part = nameParts[0];\r\n            if (isString(part)) {\r\n                const valueParts = getParts(v.value?.value);\r\n                if (valueParts.length === 0) {\r\n                    //boolean attribute <input disabled>\r\n                    return [part, true] as Property;\r\n                } else if (valueParts.length === 1) {\r\n                    //static or dynamic attribute <input value=\"text\"> or <input value=${}>\r\n                    return [part, valueParts[0]] as Property;\r\n                } else {\r\n                    //mixed static and dynamic attribute <input value=\"text ${} text ${} px\">\r\n                    return [part, valueParts] as Property;\r\n                }\r\n            } else {\r\n                //name is hole <input ${}> or <input ${}=\"anything\">. No dynamic names, treat as ref\r\n                return [\"ref\", part] as Property;\r\n            }\r\n        } else {\r\n            //name is mixed static and dynamic. We assume something like ...${} but could also be class${} or style${}. Value gets ignored in this case.\r\n            return [nameParts[0], nameParts[1]];\r\n        }\r\n    }) as Property[];\r\n\r\n    const children = node.body?.flatMap(parseNode) ?? [];\r\n    const name = node.rawName as string;\r\n\r\n    return {\r\n        type: /^[A-Z]/.test(name) ? COMPONENT_NODE : ELEMENT_NODE,\r\n        name,\r\n        props,\r\n        children,\r\n    };\r\n}\r\n\r\nfunction getParts(value: string = \"\"): Array<string | number> {\r\n    return value\r\n        .split(match)\r\n        .map((v, i) => (i % 2 === 1 ? Number(v) : v))\r\n        .filter((v) => isNumber(v) || v.trim());\r\n}","import { COMMENT_NODE, COMPONENT_NODE, ELEMENT_NODE, INSERT_NODE, TEXT_NODE, ChildNode, RootNode, ComponentNode, ROOT_NODE } from \"./parse\";\r\nimport { createComment, createElement, isString } from \"./util\";\r\n\r\n\r\n\r\n\r\n//build template element with same exact shape as tree so they can be walked through in sync\r\nexport function buildTemplate(node: RootNode | ChildNode): void {\r\n    if (node.type === ROOT_NODE || node.type === COMPONENT_NODE) {\r\n        //Criteria for using template is component or root has at least 1 element. May be be a more optimal condition.\r\n        if (node.children.some((v) => v.type === ELEMENT_NODE)) {\r\n            const template = document.createElement(\"template\");\r\n            // buildNodes(node.children, template.content);\r\n            template.innerHTML = node.children.map(buildHTML).join(\"\");\r\n            node.template = template\r\n        }\r\n        node.children.forEach(buildTemplate)\r\n    }\r\n    if (node.type === ELEMENT_NODE) {\r\n        node.children.forEach(buildTemplate)\r\n    }\r\n}\r\n\r\n\r\n//Lets browser handle svg,mathml, and html encoding\r\nfunction buildHTML(node: ChildNode): string {\r\n    switch (node.type) {\r\n        case TEXT_NODE:\r\n            return node.value;\r\n        case COMMENT_NODE:\r\n            return `<!--${node.value}-->`;\r\n        case INSERT_NODE:\r\n            return `<!--+-->`;\r\n        case COMPONENT_NODE:\r\n            return `<!--${node.name}-->`;\r\n        case ELEMENT_NODE:\r\n            let attributeHTML=\"\"\r\n            node.props = node.props.filter(([name, value]) => {\r\n                if (isString(value)) {\r\n                    attributeHTML+=` ${name}=\"${value}\"`\r\n                    return;\r\n                } else if (value === true) {\r\n                    attributeHTML+=` ${name}`\r\n                    return;\r\n                }\r\n                return true;\r\n            });\r\n\r\n\r\n            return `<${node.name}${attributeHTML}>${node.children.map(buildHTML).join(\"\")}</${node.name}>`;\r\n    }\r\n}\r\n\r\n//Building manually requires checking for MathML, SVG tags as well as html encoded chars\r\nfunction buildNodes(nodes: ChildNode[], parent: Node) {\r\n    for (const node of nodes) {\r\n        switch (node.type) {\r\n            case TEXT_NODE:\r\n                parent.appendChild(document.createTextNode(node.value));\r\n                break;\r\n            case COMMENT_NODE:\r\n                parent.appendChild(createComment(node.value));\r\n                break;\r\n            case INSERT_NODE:\r\n                parent.appendChild(createComment(\"+\"));\r\n                break;\r\n            case COMPONENT_NODE:\r\n                parent.appendChild(createComment(node.name));\r\n                break;\r\n            case ELEMENT_NODE:\r\n                const elem = createElement(node.name);\r\n                parent.appendChild(elem);\r\n\r\n                //set static attributes only and remove from props\r\n                node.props = node.props.filter(([name, value]) => {\r\n                    if (isString(value)) {\r\n                        elem.setAttribute(name, value);\r\n                        return;\r\n                    } else if (value === true) {\r\n                        elem.setAttribute(name, \"\"); //boolean attribute\r\n                        return;\r\n                    }\r\n                    return true;\r\n                });\r\n                buildNodes(node.children, elem);\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\n","import { JSX, createComponent, mergeProps } from \"solid-js\";\r\nimport {\r\n  RootNode,\r\n  ROOT_NODE,\r\n  TEXT_NODE,\r\n  INSERT_NODE,\r\n  COMMENT_NODE,\r\n  ELEMENT_NODE,\r\n  COMPONENT_NODE,\r\n  ComponentNode,\r\n  ElementNode,\r\n  parse,\r\n  ChildNode,\r\n} from \"./parse\";\r\nimport { ComponentRegistry, IntrinsicElementsMaybeFunction, SLDInstance } from \"./types\";\r\nimport {\r\n  createComment,\r\n  createElement,\r\n  flat,\r\n  toArray,\r\n  isNumber,\r\n  isString,\r\n  isBoolean,\r\n  getValue,\r\n  isFunction,\r\n  isObject,\r\n} from \"./util\";\r\nimport { SVGElements, insert, spread } from \"solid-js/web\";\r\nimport { buildTemplate } from \"./template\";\r\nimport { assignElementProperty } from \"./assign\";\r\n\r\nconst cache = new WeakMap<TemplateStringsArray, RootNode>();\r\n\r\n//Walk over text, comment, and element nodes\r\nconst walker = document.createTreeWalker(document, 133);\r\n\r\n\r\n\r\nexport function createSLD<T extends ComponentRegistry>(components: T): SLDInstance<T> {\r\n  function sld(strings: TemplateStringsArray, ...values: any[]) {\r\n    const root = getCachedRoot(strings);\r\n\r\n    return renderChildren(root, values, components);\r\n  }\r\n  sld.components = components;\r\n  sld.sld = sld;\r\n  // components = { ...defaultComponents, ...components };\r\n  sld.define = function define<TNew extends ComponentRegistry>(\r\n    newComponents: TNew\r\n  ) {\r\n    return createSLD({ ...components, ...newComponents });\r\n  };\r\n\r\n  //For TS plugin\r\n//   Object.defineProperty(sld, \"elements\", {\r\n//     get() {\r\n//       throw new Error(\r\n//         \"SLD.elements is only for types and should not be accessed at runtime. Use sld.define to add components.\"\r\n//       );\r\n//     },\r\n//   });\r\n\r\n  // Object.entries(components).forEach(([name, value]) => {\r\n  //     Object.defineProperty(sld, name, {\r\n  //         get() {\r\n  //             return (props: any) => createComponent(value, props)\r\n  //         }\r\n  //     })\r\n  // })\r\n\r\n  return sld as SLDInstance<T>;\r\n}\r\n\r\nfunction getCachedRoot(strings: TemplateStringsArray): RootNode {\r\n  let root = cache.get(strings);\r\n  if (!root) {\r\n    root = parse(strings);\r\n    buildTemplate(root);\r\n    cache.set(strings, root);\r\n    // console.log(root)\r\n  }\r\n  return root;\r\n}\r\n\r\nfunction renderNode(\r\n  node: ChildNode,\r\n  values: any[],\r\n  components: ComponentRegistry\r\n): any {\r\n  switch (node.type) {\r\n    case TEXT_NODE:\r\n      return node.value;\r\n    case INSERT_NODE:\r\n      return values[node.value];\r\n    case COMMENT_NODE:\r\n      return createComment(node.value);\r\n    case ELEMENT_NODE:\r\n      const element = createElement(node.name);\r\n      spread(\r\n        element,\r\n        gatherProps(node, values, components),\r\n        SVGElements.has(node.name),\r\n        true\r\n      );\r\n      return element;\r\n    case COMPONENT_NODE:\r\n      const component = components[node.name];\r\n      if (!component) throw new Error(`${node.name} is not defined`);\r\n      return createComponent(component, gatherProps(node, values, components));\r\n  }\r\n}\r\n\r\nfunction renderChildren(\r\n  node: ComponentNode | RootNode | ElementNode,\r\n  values: any[],\r\n  components: ComponentRegistry\r\n): JSX.Element {\r\n  const template =\r\n    (node.type === ROOT_NODE || node.type === COMPONENT_NODE) && node.template;\r\n  if (!template) {\r\n    return flat(node.children.map((n) => renderNode(n, values, components)));\r\n  }\r\n\r\n  const clone = template.content.cloneNode(true);\r\n  walker.currentNode = clone;\r\n  walkNodes(node.children);\r\n\r\n  function walkNodes(nodes: ChildNode[]) {\r\n    for (const node of nodes) {\r\n      const domNode = walker.nextNode()!;\r\n      if (node.type === ELEMENT_NODE) {\r\n        if (node.props.length) {\r\n          // for (const [name, parts] of node.props) {\r\n          //     const value =\r\n          //         isString(parts) || isBoolean(parts)\r\n          //             ? parts\r\n          //             : isNumber(parts)\r\n          //                 ? values[parts]\r\n          //                 : () =>\r\n          //                     parts\r\n          //                         .map((v) => (isNumber(v) ? getValue(values[v]) : v))\r\n          //                         .join(\"\");\r\n          //     assignElementProperty(domNode as Element, name, value, SVGElements.has(node.name))\r\n          // }\r\n          //Assigning props to element via assign prop w/effect may be better for performance.\r\n          const props = gatherProps(node, values, components);\r\n          spread(domNode as Element, props, SVGElements.has(node.name), true);\r\n        }\r\n\r\n        walkNodes(node.children);\r\n      } else if (node.type === INSERT_NODE || node.type === COMPONENT_NODE) {\r\n        insert(\r\n          domNode.parentNode!,\r\n          renderNode(node, values, components),\r\n          domNode\r\n        );\r\n        walker.currentNode = domNode;\r\n      }\r\n    }\r\n  }\r\n  return toArray(clone.childNodes);\r\n}\r\n\r\nfunction gatherProps(\r\n  node: ElementNode | ComponentNode,\r\n  values: any[],\r\n  components: ComponentRegistry,\r\n  props: Record<string, any> = {}\r\n) {\r\n  for (let [name, parts] of node.props) {\r\n    if (name === \"...\") {\r\n      if (isNumber(parts)) {\r\n        const spread = values[parts];\r\n        if (!isObject(spread)) throw new Error(\"Can only spread objects\");\r\n        // for (const n in values[parts]){\r\n        //     Object.defineProperty(props, n, {\r\n        //         get() {\r\n        //             return (spread as any)[n]\r\n        //         },\r\n        //         enumerable: true,\r\n        //     });\r\n        // }\r\n        //Or\r\n        props = mergeProps(props, spread);\r\n      }\r\n    } else {\r\n      const value =\r\n        isString(parts) || isBoolean(parts)\r\n          ? parts\r\n          : isNumber(parts)\r\n          ? values[parts]\r\n          : () =>\r\n              parts\r\n                .map((v) => (isNumber(v) ? getValue(values[v]) : v))\r\n                .join(\"\");\r\n\r\n      if (\r\n        isFunction(value) &&\r\n        value.length === 0 &&\r\n        name !== \"ref\" &&\r\n        !name.startsWith(\"on\")\r\n      ) {\r\n        Object.defineProperty(props, name, {\r\n          get() {\r\n            return value();\r\n          },\r\n          enumerable: true,\r\n        });\r\n      } else {\r\n        props[name] = value;\r\n      }\r\n    }\r\n  }\r\n\r\n  // children - childNodes overwrites any props.children\r\n  if (node.children.length) {\r\n    Object.defineProperty(props, \"children\", {\r\n      get() {\r\n        return renderChildren(node, values, components);\r\n      },\r\n    });\r\n  }\r\n  return props;\r\n}\r\n","import { createComponent, ErrorBoundary, For, Index, Match, Show, Suspense, Switch } from \"solid-js\";\r\nimport { createSLD, } from \"./sld\";\r\nimport { type FunctionComponent, type SLDInstance } from \"./types\";\r\n\r\nexport { parse } from \"./parse\";\r\nexport { createSLD, SLDInstance };\r\n\r\nexport const defaultComponents = {\r\n    For,\r\n    Index,\r\n    Match,\r\n    Suspense,\r\n    ErrorBoundary,\r\n    Show,\r\n    Switch,\r\n};\r\n\r\nexport function SLD(components = {}) {\r\n    return createSLD({ ...defaultComponents, ...components });\r\n}\r\n\r\nexport const sld = createSLD(defaultComponents)\r\n\r\nexport default sld\r\n\r\n/**\r\n * Helper function for giving better typescript to components. Wrap in createComponent but keep same signature of function. Helps for overlaods.\r\n * @param component Function of component\r\n * @returns \r\n */\r\nexport function run<T extends FunctionComponent>(component: T): T {\r\n    //@ts-expect-error\r\n    return (props)=>createComponent(component, props)\r\n}"],"mappings":"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"}