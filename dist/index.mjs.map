{"version":3,"file":"index.mjs","names":["value: any","data:string","tag: string","arr: any[]","input: TemplateStringsArray","html5parse","nodes: INode[]","node: INode","value: string","node: RootNode | ChildNode","node: ChildNode","components: T","sld","strings: TemplateStringsArray","newComponents: TNew","node: ChildNode","values: any[]","components: ComponentRegistry","node: ComponentNode | RootNode | ElementNode","nodes: ChildNode[]","node","node: ElementNode | ComponentNode","props: Record<string, any>","spread","component: T"],"sources":["../src/util.ts","../src/parse.ts","../src/template.ts","../src/sld.ts","../src/index.ts"],"sourcesContent":["import { SVGElements } from \"solid-js/web\";\r\n\r\n\r\nexport function isString(value: any): value is string {\r\n  return typeof value === \"string\";\r\n}\r\n\r\nexport function isNumber(value: any): value is number {\r\n  return typeof value === \"number\";\r\n}\r\n\r\nexport function isFunction(value: any): value is Function {\r\n  return typeof value === \"function\";\r\n}\r\n\r\nexport function isBoolean(value: any): value is boolean {\r\n  return typeof value === \"boolean\";\r\n}\r\n\r\nexport function isObject(value: any): value is object {\r\n  return typeof value === \"object\";\r\n}\r\n\r\nexport function isArray(value: any): value is any[] {\r\n  return Array.isArray(value);\r\n}\r\n\r\nexport const toArray = Array.from;\r\n\r\n\r\nexport const doc = document\r\n\r\nexport const createComment = (data:string)=>doc.createComment(data)\r\n\r\nexport function createElement(tag: string){\r\n  return SVGElements.has(tag) ? doc.createElementNS(\"http://www.w3.org/2000/svg\", tag) : doc.createElement(tag)\r\n}\r\n\r\nexport function flat(arr: any[]) {\r\n  return (arr.length === 1 ? arr[0] : arr);\r\n}\r\n\r\nexport function getValue(value: any) {\r\n  while (isFunction(value)) value = value();\r\n  return value;\r\n}","import {\r\n    SyntaxKind,\r\n    parse as html5parse,\r\n    type INode,\r\n    type IText\r\n} from \"html5parser\";\r\n\r\nimport { isNumber, isString } from \"./util\";\r\n\r\n\r\n//AST Node types\r\n\r\n//Non reactive text\r\nexport const TEXT_NODE = 1;\r\nexport type TextNode = {\r\n    type: typeof TEXT_NODE;\r\n    value: string;\r\n};\r\n\r\n//Non reactive Comment Node <!--value-->\r\nexport const COMMENT_NODE = 2;\r\nexport type CommentNode = {\r\n    type: typeof COMMENT_NODE;\r\n    value: string;\r\n};\r\n\r\n//Reactive Hole\r\nexport const INSERT_NODE = 3;\r\nexport type InsertNode = {\r\n    type: typeof INSERT_NODE;\r\n    value: number; //index of hole\r\n};\r\n\r\nexport const ELEMENT_NODE = 4;\r\nexport type ElementNode = {\r\n    type: typeof ELEMENT_NODE;\r\n    name: string;\r\n    props: Property[];\r\n    children: ChildNode[];\r\n};\r\n\r\nexport const COMPONENT_NODE = 5;\r\nexport type ComponentNode = {\r\n    type: typeof COMPONENT_NODE;\r\n    name: string;\r\n    props: Property[];\r\n    children: ChildNode[];\r\n    template?: HTMLTemplateElement\r\n};\r\n\r\nexport const ROOT_NODE = 6;\r\nexport type RootNode = {\r\n    type: typeof ROOT_NODE;\r\n    children: ChildNode[];\r\n    template?: HTMLTemplateElement\r\n};\r\n\r\nexport type ChildNode =\r\n    | TextNode\r\n    | ComponentNode\r\n    | ElementNode\r\n    | InsertNode\r\n    | CommentNode;\r\n\r\nexport type Property = [name: string, value: ValueParts];\r\n\r\n//string or boolean means static, number means hole and is index, array means mix of string and holes\r\nexport type ValueParts = string | boolean | number | Array<string | number>;\r\n\r\n//Needs to be unique character that would never be in the template literal\r\nconst marker = \"⧙⧘\";\r\n\r\n//Captures index of hole\r\nconst match = new RegExp(`${marker}(\\\\d+)${marker}`, \"g\");\r\n\r\n/**\r\n * \r\n * @param input jsx like string to parse\r\n * @returns RootNode of an AST\r\n */\r\nexport function parse(input: TemplateStringsArray): RootNode {\r\n    const ast = html5parse(\r\n        input\r\n            .slice(1)\r\n            .reduce(\r\n                (prev, current, index) => prev + marker + index + marker + current,\r\n                input[0],\r\n            ),\r\n    );\r\n    return {\r\n        type: ROOT_NODE,\r\n        children: parseNodes(ast)\r\n    }\r\n}\r\n\r\nfunction parseNodes(nodes: INode[]) {\r\n    return nodes.flatMap(parseNode)\r\n}\r\n//Parse html5parser result for what we care about\r\nfunction parseNode(\r\n    node: INode,\r\n): ChildNode | ChildNode[] {\r\n    //Text nodes are either static text or holes to insert in\r\n    if (node.type === SyntaxKind.Text) {\r\n        const parts = getParts(node.value);\r\n        return parts.map((value) => {\r\n            const type = isString(value) ? TEXT_NODE : INSERT_NODE;\r\n            return {\r\n                type,\r\n                value,\r\n            } as InsertNode | TextNode;\r\n        });\r\n    }\r\n\r\n    //html5parser represents comments as type tag with name \"!\" or \"\"\r\n    if (node.name[0] === \"!\" || node.name === \"\") {\r\n        return {\r\n            type: COMMENT_NODE,\r\n            value: (node.body as IText[]).reduce((p,v)=>p+=v.value,\"\"),\r\n        } as CommentNode;\r\n    }\r\n\r\n    const props = node.attributes.map((v) => {\r\n        const nameParts = getParts(v.name.value);\r\n\r\n        if (nameParts.length === 1) {\r\n            const part = nameParts[0];\r\n            if (isString(part)) {\r\n                const valueParts = getParts(v.value?.value);\r\n                if (valueParts.length === 0) {\r\n                    //boolean attribute <input disabled>\r\n                    return [part, true] as Property;\r\n                } else if (valueParts.length === 1) {\r\n                    //static or dynamic attribute <input value=\"text\"> or <input value=${}>\r\n                    return [part, valueParts[0]] as Property;\r\n                } else {\r\n                    //mixed static and dynamic attribute <input value=\"text ${} text ${} px\">\r\n                    return [part, valueParts] as Property;\r\n                }\r\n            } else {\r\n                //name is hole <input ${}> or <input ${}=\"anything\">. No dynamic names, treat as ref\r\n                return [\"ref\", part] as Property;\r\n            }\r\n        } else {\r\n            //name is mixed static and dynamic. We assume something like ...${} but could also be class${} or style${}. Value gets ignored in this case.\r\n            return [nameParts[0], nameParts[1]];\r\n        }\r\n    }) as Property[];\r\n\r\n    const children = node.body?.flatMap(parseNode) ?? [];\r\n    const name = node.rawName as string;\r\n\r\n    return {\r\n        type: /^[A-Z]/.test(name) ? COMPONENT_NODE : ELEMENT_NODE,\r\n        name,\r\n        props,\r\n        children,\r\n    };\r\n}\r\n\r\nfunction getParts(value: string = \"\"): Array<string | number> {\r\n    return value\r\n        .split(match)\r\n        .map((v, i) => (i % 2 === 1 ? Number(v) : v))\r\n        .filter((v) => isNumber(v) || v.trim());\r\n}","import { COMMENT_NODE, COMPONENT_NODE, ELEMENT_NODE, INSERT_NODE, TEXT_NODE, ChildNode, RootNode, ComponentNode, ROOT_NODE } from \"./parse\";\r\nimport { createComment, createElement, isString } from \"./util\";\r\n\r\n\r\n\r\n\r\n//build template element with same exact shape as tree so they can be walked through in sync\r\nexport function buildTemplate(node: RootNode | ChildNode): void {\r\n    if (node.type === ROOT_NODE || node.type === COMPONENT_NODE) {\r\n        //Criteria for using template is component or root has at least 1 element. May be be a more optimal condition.\r\n        if (node.children.some((v) => v.type === ELEMENT_NODE)) {\r\n            const template = document.createElement(\"template\");\r\n            // buildNodes(node.children, template.content);\r\n            template.innerHTML = node.children.map(buildHTML).join(\"\");\r\n            node.template = template\r\n        }\r\n        node.children.forEach(buildTemplate)\r\n    }\r\n    if (node.type === ELEMENT_NODE) {\r\n        node.children.forEach(buildTemplate)\r\n    }\r\n}\r\n\r\n\r\n//Lets browser handle svg,mathml, and html encoding\r\nfunction buildHTML(node: ChildNode): string {\r\n    switch (node.type) {\r\n        case TEXT_NODE:\r\n            return node.value;\r\n        case COMMENT_NODE:\r\n            return `<!--${node.value}-->`;\r\n        case INSERT_NODE:\r\n            return `<!--+-->`;\r\n        case COMPONENT_NODE:\r\n            return `<!--${node.name}-->`;\r\n        case ELEMENT_NODE:\r\n            let attributeHTML=\"\"\r\n            node.props = node.props.filter(([name, value]) => {\r\n                if (isString(value)) {\r\n                    attributeHTML+=` ${name}=\"${value}\"`\r\n                    return;\r\n                } else if (value === true) {\r\n                    attributeHTML+=` ${name}`\r\n                    return;\r\n                }\r\n                return true;\r\n            });\r\n\r\n\r\n            return `<${node.name}${attributeHTML}>${node.children.map(buildHTML).join(\"\")}</${node.name}>`;\r\n    }\r\n}\r\n\r\n//Building manually requires checking for MathML, SVG tags as well as html encoded chars\r\nfunction buildNodes(nodes: ChildNode[], parent: Node) {\r\n    for (const node of nodes) {\r\n        switch (node.type) {\r\n            case TEXT_NODE:\r\n                parent.appendChild(document.createTextNode(node.value));\r\n                break;\r\n            case COMMENT_NODE:\r\n                parent.appendChild(createComment(node.value));\r\n                break;\r\n            case INSERT_NODE:\r\n                parent.appendChild(createComment(\"+\"));\r\n                break;\r\n            case COMPONENT_NODE:\r\n                parent.appendChild(createComment(node.name));\r\n                break;\r\n            case ELEMENT_NODE:\r\n                const elem = createElement(node.name);\r\n                parent.appendChild(elem);\r\n\r\n                //set static attributes only and remove from props\r\n                node.props = node.props.filter(([name, value]) => {\r\n                    if (isString(value)) {\r\n                        elem.setAttribute(name, value);\r\n                        return;\r\n                    } else if (value === true) {\r\n                        elem.setAttribute(name, \"\"); //boolean attribute\r\n                        return;\r\n                    }\r\n                    return true;\r\n                });\r\n                buildNodes(node.children, elem);\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\n","import { JSX, createComponent, mergeProps } from \"solid-js\";\r\nimport { RootNode, ROOT_NODE, TEXT_NODE, INSERT_NODE, COMMENT_NODE, ELEMENT_NODE, COMPONENT_NODE, ComponentNode, ElementNode, parse, ChildNode } from \"./parse\";\r\nimport { ComponentRegistry } from \"./types\";\r\nimport { createComment, createElement, flat, toArray, isNumber, isString, isBoolean, getValue, isFunction, isObject } from \"./util\";\r\nimport { SVGElements, insert, spread } from \"solid-js/web\";\r\nimport { buildTemplate } from \"./template\";\r\nimport { assignElementProperty } from \"./assign\";\r\n\r\nconst cache = new WeakMap<TemplateStringsArray, RootNode>();\r\n\r\n//Walk over text, comment, and element nodes\r\nconst walker = document.createTreeWalker(document, 133);\r\n\r\nexport type SLD<T extends ComponentRegistry> = {\r\n    (strings: TemplateStringsArray, ...values: any[]): JSX.Element\r\n    sld: SLD<T>;\r\n    define<TNew extends ComponentRegistry>(\r\n        components: TNew,\r\n    ): SLD<T & TNew>;\r\n    components: T;\r\n};\r\n\r\nexport function createSLD<T extends ComponentRegistry>(\r\n    components: T,\r\n): SLD<T> {\r\n    function sld(strings: TemplateStringsArray, ...values: any[]) {\r\n        const root = getCachedRoot(strings);\r\n\r\n\r\n        return renderChildren(root, values, components);\r\n    }\r\n    sld.components = components;\r\n    sld.sld = sld\r\n    // components = { ...defaultComponents, ...components };\r\n    sld.define = function define<TNew extends ComponentRegistry>(newComponents: TNew) {\r\n        return createSLD({ ...components, ...newComponents });\r\n    }\r\n    \r\n\r\n    // Object.entries(components).forEach(([name, value]) => {\r\n    //     Object.defineProperty(sld, name, {\r\n    //         get() {\r\n    //             return (props: any) => createComponent(value, props)\r\n    //         }\r\n    //     })\r\n    // })\r\n\r\n    return sld\r\n}\r\n\r\nfunction getCachedRoot(\r\n    strings: TemplateStringsArray,\r\n): RootNode {\r\n    let root = cache.get(strings);\r\n    if (!root) {\r\n        root = parse(strings)\r\n        buildTemplate(root)\r\n        cache.set(strings, root);\r\n        // console.log(root)\r\n    }\r\n    return root;\r\n}\r\n\r\nfunction renderNode(node: ChildNode, values: any[], components: ComponentRegistry): any {\r\n    switch (node.type) {\r\n        case TEXT_NODE:\r\n            return node.value;\r\n        case INSERT_NODE:\r\n            return values[node.value];\r\n        case COMMENT_NODE:\r\n            return createComment(node.value);\r\n        case ELEMENT_NODE:\r\n            const element = createElement(node.name);\r\n            spread(\r\n                element,\r\n                gatherProps(node, values, components),\r\n                SVGElements.has(node.name),\r\n                true,\r\n            );\r\n            return element;\r\n        case COMPONENT_NODE:\r\n            const component = components[node.name]\r\n            if (!component) throw new Error(`${node.name} is not defined`)\r\n            return createComponent(component, gatherProps(node, values, components));\r\n    }\r\n}\r\n\r\nfunction renderChildren(\r\n    node: ComponentNode | RootNode | ElementNode,\r\n    values: any[],\r\n    components: ComponentRegistry\r\n): JSX.Element {\r\n    const template =\r\n        (node.type === ROOT_NODE || node.type === COMPONENT_NODE) && node.template;\r\n    if (!template) {\r\n        return flat(node.children.map((n) => renderNode(n, values, components)));\r\n    }\r\n\r\n    const clone = template.content.cloneNode(true);\r\n    walker.currentNode = clone;\r\n    walkNodes(node.children);\r\n\r\n    function walkNodes(nodes: ChildNode[]) {\r\n        for (const node of nodes) {\r\n            const domNode = walker.nextNode()!;\r\n            if (node.type === ELEMENT_NODE) {\r\n\r\n                if (node.props.length) {\r\n                    // for (const [name, parts] of node.props) {\r\n                    //     const value =\r\n                    //         isString(parts) || isBoolean(parts)\r\n                    //             ? parts\r\n                    //             : isNumber(parts)\r\n                    //                 ? values[parts]\r\n                    //                 : () =>\r\n                    //                     parts\r\n                    //                         .map((v) => (isNumber(v) ? getValue(values[v]) : v))\r\n                    //                         .join(\"\");\r\n                    //     assignElementProperty(domNode as Element, name, value, SVGElements.has(node.name))\r\n                    // }\r\n                    //Assigning props to element via assign prop w/effect may be better for performance.\r\n                    const props = gatherProps(node, values, components);\r\n                    spread(domNode as Element, props, SVGElements.has(node.name), true);\r\n                }\r\n\r\n                walkNodes(node.children);\r\n            } else if (node.type === INSERT_NODE || node.type === COMPONENT_NODE) {\r\n                insert(domNode.parentNode!, renderNode(node, values, components), domNode);\r\n                walker.currentNode = domNode;\r\n            }\r\n        }\r\n    }\r\n    return toArray(clone.childNodes);\r\n}\r\n\r\nfunction gatherProps(node: ElementNode | ComponentNode, values: any[], components: ComponentRegistry, props: Record<string, any> = {}) {\r\n    for (let [name, parts] of node.props) {\r\n        if (name === \"...\") {\r\n            if (isNumber(parts)) {\r\n                const spread = values[parts]\r\n                if (!isObject(spread)) throw new Error(\"Can only spread objects\")\r\n                // for (const n in values[parts]){\r\n                //     Object.defineProperty(props, n, {\r\n                //         get() {\r\n                //             return (spread as any)[n]\r\n                //         },\r\n                //         enumerable: true,\r\n                //     });\r\n                // }\r\n                //Or\r\n                props = mergeProps(props, spread)\r\n            }\r\n        } else {\r\n            const value =\r\n                isString(parts) || isBoolean(parts)\r\n                    ? parts\r\n                    : isNumber(parts)\r\n                        ? values[parts]\r\n                        : () =>\r\n                            parts\r\n                                .map((v) => (isNumber(v) ? getValue(values[v]) : v))\r\n                                .join(\"\");\r\n\r\n            if (\r\n                isFunction(value) &&\r\n                value.length === 0 &&\r\n                name !== \"ref\" &&\r\n                !name.startsWith(\"on\")\r\n            ) {\r\n                Object.defineProperty(props, name, {\r\n                    get() {\r\n                        return value();\r\n                    },\r\n                    enumerable: true,\r\n                });\r\n            } else {\r\n                props[name] = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    // children - childNodes overwrites any props.children\r\n    if (node.children.length) {\r\n        Object.defineProperty(props, \"children\", {\r\n            get() {\r\n                return renderChildren(node, values, components);\r\n            },\r\n        });\r\n    }\r\n    return props;\r\n}\r\n","import { createComponent, ErrorBoundary, For, Index, Match, Show, Suspense, Switch } from \"solid-js\";\r\nimport { createSLD, type SLD } from \"./sld\";\r\nimport { FunctionComponent } from \"./types\";\r\n\r\nexport { parse } from \"./parse\";\r\n\r\nexport const defaultComponents = {\r\n    For,\r\n    Index,\r\n    Match,\r\n    Suspense,\r\n    ErrorBoundary,\r\n    Show,\r\n    Switch,\r\n};\r\n\r\nexport function SLD(components = {}) {\r\n    return createSLD({ ...defaultComponents, ...components });\r\n}\r\n\r\nexport const sld = createSLD(defaultComponents)\r\n\r\nexport default sld\r\n\r\n/**\r\n * Helper function for giving better typescript to components. Wrap in createComponent but keep same signature of function. Helps for overlaods.\r\n * @param component Function of component\r\n * @returns \r\n */\r\nexport function comp<T extends FunctionComponent>(component: T): T {\r\n    //@ts-expect-error\r\n    return (props)=>createComponent(component, props)\r\n}"],"mappings":"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"}