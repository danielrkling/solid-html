{"version":3,"file":"index.mjs","names":["value: any","data:string","tag: string","arr: any[]","input: TemplateStringsArray","html5parse","nodes: INode[]","node: INode","value: string","node: RootNode | ChildNode","node: ChildNode","components: T","sld","strings: TemplateStringsArray","newComponents: TNew","props: any","node: ChildNode","values: any[]","components: ComponentRegistry","node: ComponentNode | RootNode | ElementNode","nodes: ChildNode[]","node","node: ElementNode | ComponentNode","props: Record<string, any>","spread","component: T"],"sources":["../src/util.ts","../src/parse.ts","../src/template.ts","../src/sld.ts","../src/index.ts"],"sourcesContent":["import { SVGElements } from \"solid-js/web\";\n\n\nexport function isString(value: any): value is string {\n  return typeof value === \"string\";\n}\n\nexport function isNumber(value: any): value is number {\n  return typeof value === \"number\";\n}\n\nexport function isFunction(value: any): value is Function {\n  return typeof value === \"function\";\n}\n\nexport function isBoolean(value: any): value is boolean {\n  return typeof value === \"boolean\";\n}\n\nexport function isObject(value: any): value is object {\n  return typeof value === \"object\";\n}\n\nexport function isArray(value: any): value is any[] {\n  return Array.isArray(value);\n}\n\nexport const toArray = Array.from;\n\n\nexport const doc = document\n\nexport const createComment = (data:string)=>doc.createComment(data)\n\nexport function createElement(tag: string){\n  return SVGElements.has(tag) ? doc.createElementNS(\"http://www.w3.org/2000/svg\", tag) : doc.createElement(tag)\n}\n\nexport function flat(arr: any[]) {\n  return (arr.length === 1 ? arr[0] : arr);\n}\n\nexport function getValue(value: any) {\n  while (isFunction(value)) value = value();\n  return value;\n}","import {\n    SyntaxKind,\n    parse as html5parse,\n    type INode,\n    type IText\n} from \"html5parser\";\n\nimport { isNumber, isString } from \"./util\";\n\n\n//AST Node types\n\n//Non reactive text\nexport const TEXT_NODE = 1;\nexport type TextNode = {\n    type: typeof TEXT_NODE;\n    value: string;\n};\n\n//Non reactive Comment Node <!--value-->\nexport const COMMENT_NODE = 2;\nexport type CommentNode = {\n    type: typeof COMMENT_NODE;\n    value: string;\n};\n\n//Reactive Hole\nexport const INSERT_NODE = 3;\nexport type InsertNode = {\n    type: typeof INSERT_NODE;\n    value: number; //index of hole\n};\n\nexport const ELEMENT_NODE = 4;\nexport type ElementNode = {\n    type: typeof ELEMENT_NODE;\n    name: string;\n    props: Property[];\n    children: ChildNode[];\n};\n\nexport const COMPONENT_NODE = 5;\nexport type ComponentNode = {\n    type: typeof COMPONENT_NODE;\n    name: string;\n    props: Property[];\n    children: ChildNode[];\n    template?: HTMLTemplateElement\n};\n\nexport const ROOT_NODE = 6;\nexport type RootNode = {\n    type: typeof ROOT_NODE;\n    children: ChildNode[];\n    template?: HTMLTemplateElement\n};\n\nexport type ChildNode =\n    | TextNode\n    | ComponentNode\n    | ElementNode\n    | InsertNode\n    | CommentNode;\n\nexport type Property = [name: string, value: ValueParts];\n\n//string or boolean means static, number means hole and is index, array means mix of string and holes\nexport type ValueParts = string | boolean | number | Array<string | number>;\n\n//Needs to be unique character that would never be in the template literal\nconst marker = \"⧙⧘\";\n\n//Captures index of hole\nconst match = new RegExp(`${marker}(\\\\d+)${marker}`, \"g\");\n\n/**\n * \n * @param input jsx like string to parse\n * @returns RootNode of an AST\n */\nexport function parse(input: TemplateStringsArray): RootNode {\n    const ast = html5parse(\n        input\n            .slice(1)\n            .reduce(\n                (prev, current, index) => prev + marker + index + marker + current,\n                input[0],\n            ),\n    );\n    return {\n        type: ROOT_NODE,\n        children: parseNodes(ast)\n    }\n}\n\nfunction parseNodes(nodes: INode[]) {\n    return nodes.flatMap(parseNode)\n}\n//Parse html5parser result for what we care about\nfunction parseNode(\n    node: INode,\n): ChildNode | ChildNode[] {\n    //Text nodes are either static text or holes to insert in\n    if (node.type === SyntaxKind.Text) {\n        const parts = getParts(node.value);\n        return parts.map((value) => {\n            const type = isString(value) ? TEXT_NODE : INSERT_NODE;\n            return {\n                type,\n                value,\n            } as InsertNode | TextNode;\n        });\n    }\n\n    //html5parser represents comments as type tag with name \"!\" or \"\"\n    if (node.name[0] === \"!\" || node.name === \"\") {\n        return {\n            type: COMMENT_NODE,\n            value: (node.body as IText[]).reduce((p,v)=>p+=v.value,\"\"),\n        } as CommentNode;\n    }\n\n    const props = node.attributes.map((v) => {\n        const nameParts = getParts(v.name.value);\n\n        if (nameParts.length === 1) {\n            const part = nameParts[0];\n            if (isString(part)) {\n                const valueParts = getParts(v.value?.value);\n                if (valueParts.length === 0) {\n                    //boolean attribute <input disabled>\n                    return [part, true] as Property;\n                } else if (valueParts.length === 1) {\n                    //static or dynamic attribute <input value=\"text\"> or <input value=${}>\n                    return [part, valueParts[0]] as Property;\n                } else {\n                    //mixed static and dynamic attribute <input value=\"text ${} text ${} px\">\n                    return [part, valueParts] as Property;\n                }\n            } else {\n                //name is hole <input ${}> or <input ${}=\"anything\">. No dynamic names, treat as ref\n                return [\"ref\", part] as Property;\n            }\n        } else {\n            //name is mixed static and dynamic. We assume something like ...${} but could also be class${} or style${}. Value gets ignored in this case.\n            return [nameParts[0], nameParts[1]];\n        }\n    }) as Property[];\n\n    const children = node.body?.flatMap(parseNode) ?? [];\n    const name = node.rawName as string;\n\n    return {\n        type: /^[A-Z]/.test(name) ? COMPONENT_NODE : ELEMENT_NODE,\n        name,\n        props,\n        children,\n    };\n}\n\nfunction getParts(value: string = \"\"): Array<string | number> {\n    return value\n        .split(match)\n        .map((v, i) => (i % 2 === 1 ? Number(v) : v))\n        .filter((v) => isNumber(v) || v.trim());\n}","import { COMMENT_NODE, COMPONENT_NODE, ELEMENT_NODE, INSERT_NODE, TEXT_NODE, ChildNode, RootNode, ComponentNode, ROOT_NODE } from \"./parse\";\nimport { createComment, createElement, isString } from \"./util\";\n\n\n\n\n//build template element with same exact shape as tree so they can be walked through in sync\nexport function buildTemplate(node: RootNode | ChildNode): void {\n    if (node.type === ROOT_NODE || node.type === COMPONENT_NODE) {\n        //Criteria for using template is component or root has at least 1 element. May be be a more optimal condition.\n        if (node.children.some((v) => v.type === ELEMENT_NODE)) {\n            const template = document.createElement(\"template\");\n            // buildNodes(node.children, template.content);\n            template.innerHTML = node.children.map(buildHTML).join(\"\");\n            node.template = template\n        }\n        node.children.forEach(buildTemplate)\n    }\n    if (node.type === ELEMENT_NODE) {\n        node.children.forEach(buildTemplate)\n    }\n}\n\n\n//Lets browser handle svg,mathml, and html encoding\nfunction buildHTML(node: ChildNode): string {\n    switch (node.type) {\n        case TEXT_NODE:\n            return node.value;\n        case COMMENT_NODE:\n            return `<!--${node.value}-->`;\n        case INSERT_NODE:\n            return `<!--+-->`;\n        case COMPONENT_NODE:\n            return `<!--${node.name}-->`;\n        case ELEMENT_NODE:\n            let attributeHTML=\"\"\n            node.props = node.props.filter(([name, value]) => {\n                if (isString(value)) {\n                    attributeHTML+=` ${name}=\"${value}\"`\n                    return;\n                } else if (value === true) {\n                    attributeHTML+=` ${name}`\n                    return;\n                }\n                return true;\n            });\n\n\n            return `<${node.name}${attributeHTML}>${node.children.map(buildHTML).join(\"\")}</${node.name}>`;\n    }\n}\n\n//Building manually requires checking for MathML, SVG tags as well as html encoded chars\nfunction buildNodes(nodes: ChildNode[], parent: Node) {\n    for (const node of nodes) {\n        switch (node.type) {\n            case TEXT_NODE:\n                parent.appendChild(document.createTextNode(node.value));\n                break;\n            case COMMENT_NODE:\n                parent.appendChild(createComment(node.value));\n                break;\n            case INSERT_NODE:\n                parent.appendChild(createComment(\"+\"));\n                break;\n            case COMPONENT_NODE:\n                parent.appendChild(createComment(node.name));\n                break;\n            case ELEMENT_NODE:\n                const elem = createElement(node.name);\n                parent.appendChild(elem);\n\n                //set static attributes only and remove from props\n                node.props = node.props.filter(([name, value]) => {\n                    if (isString(value)) {\n                        elem.setAttribute(name, value);\n                        return;\n                    } else if (value === true) {\n                        elem.setAttribute(name, \"\"); //boolean attribute\n                        return;\n                    }\n                    return true;\n                });\n                buildNodes(node.children, elem);\n                break;\n        }\n    }\n}\n\n","import { JSX, createComponent, mergeProps } from \"solid-js\";\nimport { RootNode, ROOT_NODE, TEXT_NODE, INSERT_NODE, COMMENT_NODE, ELEMENT_NODE, COMPONENT_NODE, ComponentNode, ElementNode, parse, ChildNode } from \"./parse\";\nimport { ComponentRegistry } from \"./types\";\nimport { createComment, createElement, flat, toArray, isNumber, isString, isBoolean, getValue, isFunction, isObject } from \"./util\";\nimport { SVGElements, insert, spread } from \"solid-js/web\";\nimport { buildTemplate } from \"./template\";\nimport { assignElementProperty } from \"./assign\";\n\nconst cache = new WeakMap<TemplateStringsArray, RootNode>();\n\n//Walk over text, comment, and element nodes\nconst walker = document.createTreeWalker(document, 133);\n\nexport type SLD<T extends ComponentRegistry> = {\n    (strings: TemplateStringsArray, ...values: any[]): JSX.Element\n    sld(strings: TemplateStringsArray, ...values: any[]): JSX.Element;\n    define<TNew extends ComponentRegistry>(\n        components: TNew,\n    ): SLD<T & TNew>;\n} & T;\n\nexport function SLD<T extends ComponentRegistry>(\n    components: T,\n): SLD<T> {\n    function sld(strings: TemplateStringsArray, ...values: any[]) {\n        const root = getCachedRoot(strings);\n\n\n        return renderChildren(root, values, components);\n    }\n\n    // components = { ...defaultComponents, ...components };\n    sld.define = function define<TNew extends ComponentRegistry>(newComponents: TNew) {\n        return SLD({ ...components, ...newComponents });\n    }\n    sld.sld = sld\n\n    Object.entries(components).forEach(([name, value]) => {\n        Object.defineProperty(sld, name, {\n            get() {\n                return (props: any) => createComponent(value, props)\n            }\n        })\n    })\n\n    //@ts-expect-error\n    return sld\n}\n\nfunction getCachedRoot(\n    strings: TemplateStringsArray,\n): RootNode {\n    let root = cache.get(strings);\n    if (!root) {\n        root = parse(strings)\n        buildTemplate(root)\n        cache.set(strings, root);\n        // console.log(root)\n    }\n    return root;\n}\n\nfunction renderNode(node: ChildNode, values: any[], components: ComponentRegistry): any {\n    switch (node.type) {\n        case TEXT_NODE:\n            return node.value;\n        case INSERT_NODE:\n            return values[node.value];\n        case COMMENT_NODE:\n            return createComment(node.value);\n        case ELEMENT_NODE:\n            const element = createElement(node.name);\n            spread(\n                element,\n                gatherProps(node, values, components),\n                SVGElements.has(node.name),\n                true,\n            );\n            return element;\n        case COMPONENT_NODE:\n            const component = components[node.name]\n            if (!component) throw new Error(`${node.name} is not defined`)\n            return createComponent(component, gatherProps(node, values, components));\n    }\n}\n\nfunction renderChildren(\n    node: ComponentNode | RootNode | ElementNode,\n    values: any[],\n    components: ComponentRegistry\n): JSX.Element {\n    const template =\n        (node.type === ROOT_NODE || node.type === COMPONENT_NODE) && node.template;\n    if (!template) {\n        return flat(node.children.map((n) => renderNode(n, values, components)));\n    }\n\n    const clone = template.content.cloneNode(true);\n    walker.currentNode = clone;\n    walkNodes(node.children);\n\n    function walkNodes(nodes: ChildNode[]) {\n        for (const node of nodes) {\n            const domNode = walker.nextNode()!;\n            if (node.type === ELEMENT_NODE) {\n\n                if (node.props.length) {\n                    // for (const [name, parts] of node.props) {\n                    //     const value =\n                    //         isString(parts) || isBoolean(parts)\n                    //             ? parts\n                    //             : isNumber(parts)\n                    //                 ? values[parts]\n                    //                 : () =>\n                    //                     parts\n                    //                         .map((v) => (isNumber(v) ? getValue(values[v]) : v))\n                    //                         .join(\"\");\n                    //     assignElementProperty(domNode as Element, name, value, SVGElements.has(node.name))\n                    // }\n                    //Assigning props to element via assign prop w/effect may be better for performance.\n                    const props = gatherProps(node, values, components);\n                    spread(domNode as Element, props, SVGElements.has(node.name), true);\n                }\n\n                walkNodes(node.children);\n            } else if (node.type === INSERT_NODE || node.type === COMPONENT_NODE) {\n                insert(domNode.parentNode!, renderNode(node, values, components), domNode);\n                walker.currentNode = domNode;\n            }\n        }\n    }\n    return toArray(clone.childNodes);\n}\n\nfunction gatherProps(node: ElementNode | ComponentNode, values: any[], components: ComponentRegistry, props: Record<string, any> = {}) {\n    for (let [name, parts] of node.props) {\n        if (name === \"...\") {\n            if (isNumber(parts)) {\n                const spread = values[parts]\n                if (!isObject(spread)) throw new Error(\"Can only spread objects\")\n                // for (const n in values[parts]){\n                //     Object.defineProperty(props, n, {\n                //         get() {\n                //             return (spread as any)[n]\n                //         },\n                //         enumerable: true,\n                //     });\n                // }\n                //Or\n                props = mergeProps(props, spread)\n            }\n        } else {\n            const value =\n                isString(parts) || isBoolean(parts)\n                    ? parts\n                    : isNumber(parts)\n                        ? values[parts]\n                        : () =>\n                            parts\n                                .map((v) => (isNumber(v) ? getValue(values[v]) : v))\n                                .join(\"\");\n\n            if (\n                isFunction(value) &&\n                value.length === 0 &&\n                name !== \"ref\" &&\n                !name.startsWith(\"on\")\n            ) {\n                Object.defineProperty(props, name, {\n                    get() {\n                        return value();\n                    },\n                    enumerable: true,\n                });\n            } else {\n                props[name] = value;\n            }\n        }\n    }\n\n    // children - childNodes overwrites any props.children\n    if (node.children.length) {\n        Object.defineProperty(props, \"children\", {\n            get() {\n                return renderChildren(node, values, components);\n            },\n        });\n    }\n    return props;\n}\n","import { Dynamic, ErrorBoundary, For, Index, Match, NoHydration, Portal, Show, Suspense, Switch } from \"solid-js/web\";\nimport { SLD } from \"./sld\";\nimport { createComponent } from \"solid-js\";\nimport { FunctionComponent } from \"./types\";\n\nexport {parse} from \"./parse\"\n\nexport {SLD}\n\nexport const defaultComponents = {\n    For,\n    Index,\n    Match,\n    Suspense,\n    ErrorBoundary,\n    Show,\n    Switch,\n    Dynamic,\n    Portal,\n    NoHydration,\n};\n\nexport const sld = SLD(defaultComponents)\n\nexport default sld\n\n/**\n * Helper function for giving better typescript to components. Wrap in createComponent but keep same signature of function. Helps for overlaods.\n * @param component Function of component\n * @returns \n */\nexport function comp<T extends FunctionComponent>(component: T): T {\n    //@ts-expect-error\n    return (props)=>createComponent(component, props)\n}"],"mappings":"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"}