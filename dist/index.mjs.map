{"version":3,"file":"index.mjs","names":["value: MaybeFunction<T>","when: () => T","children: (item: Accessor<NonNullable<T>>)=>JSX.Element","fallback?: ()=>JSX.Element","_Show","children: ((item: NonNullable<T>) => JSX.Element)","children: ()=>JSX.Element[]","fallback: ()=>JSX.Element","_Switch","children: ((item: Accessor<NonNullable<T>>) => JSX.Element)","_Match","each: () => T | false | null | undefined","children: (item: T[number], index: () => number) => JSX.Element","_For","children: (item: () => T[number], index: number) => JSX.Element","_Index","children: ()=>JSX.Element","_Suspense","fallback: ((err: any, reset: () => void) => JSX.Element)","_ErrorBoundary","context: _Context<T>","value: T","children: () => JSX.Element","value: any","node: Element","name: string","value: any","prev?: any","namespace: string","rules: AssignmentRule[]","elem: Element","assign","props: any","prev: any","strings: TemplateStringsArray","arr: any[]","getValue","value: any","components: ComponentRegistry","rules: AssignmentRule[]","html","template: HTMLTemplateElement","componentNode: ComponentNode | RootNode","clone","nodes: TreeNode[]","node: TreeNode","parts: ValueParts","values: any[]","value: string","node: INode","parent: Node","defaultRules: AssignmentRule[]","defaultComponents: ComponentRegistry","components: Record<string, any>","rules: AssignmentRule[]","h","component: T","props: MaybeFunctionProps<ComponentProps<T>>","components: Record<string, ValidComponent>","components","tag: string","fn: T","props: TProps"],"sources":["../src/components.ts","../src/util.ts","../src/assign.ts","../src/html.ts","../src/defaults.ts","../src/h.ts"],"sourcesContent":["import {\n  type Context as _Context,\n  ErrorBoundary as _ErrorBoundary,\n  For as _For,\n  Index as _Index,\n  Match as _Match,\n  Show as _Show,\n  Suspense as _Suspense,\n  Switch as _Switch,\n  createComponent,\n  JSX,\n  Accessor,\n} from \"solid-js\";\nimport { MaybeFunction } from \"./types\";\n\nexport function getValue<T>(value: MaybeFunction<T>): T {\n  if (typeof value === \"function\") {\n    //@ts-expect-error\n    return value();\n  }else{\n    return value;\n  }\n}\n\n/**\n * Solid-compatible Show component. Renders children if `when` is truthy, otherwise renders `fallback`.\n * @example\n * Show(() => isVisible(), html`<span>Hello</span>`, \"Fallback\")\n */\nexport function Show<T>(\n  when: () => T,\n  children: (item: Accessor<NonNullable<T>>)=>JSX.Element,\n  fallback?: ()=>JSX.Element\n): JSX.Element {\n  return createComponent(_Show, {\n    get when() {\n      return when();\n    },\n    //@ts-expect-error\n    children,\n    get fallback(){\n      return fallback?.()\n    },\n    //@ts-expect-error\n    keyed: false,\n  });\n}\n\n\n\n/**\n * Show component with keyed mode. Renders children with keyed context if `when` is truthy.\n * @example\n * ShowKeyed(() => user(), user => html`<span>${user.name}</span>`, \"No user\")\n */\nexport function ShowKeyed<T>(\n  when: () => T,\n  children: ((item: NonNullable<T>) => JSX.Element),\n  fallback?: ()=>JSX.Element\n): JSX.Element {\n  return createComponent(_Show, {\n    get when() {\n      return when();\n    },\n    //@ts-expect-error\n    children,\n    get fallback(){\n      return fallback?.()\n    },\n    keyed: true,\n  });\n}\n\n/**\n * Switch component for conditional rendering. Renders the first matching child, or `fallback` if none match.\n * @example\n * Switch(\"No match\", Match(() => cond1(), html`A`), Match(() => cond2(), html`B`))\n */\nexport function Switch(\n  children: ()=>JSX.Element[],\n  fallback: ()=>JSX.Element,  \n): JSX.Element {\n  return createComponent(_Switch, {\n    get fallback() {\n      return fallback();\n    },\n    get children(){\n      return children()\n    }\n  });\n}\n\n/**\n * Match component for use inside Switch. Renders children if `when` is truthy.\n * @example\n * Match(() => value() === 1, html`One`)\n */\nexport function Match<T>(\n  when: () => T,\n  children: ((item: Accessor<NonNullable<T>>) => JSX.Element)\n): JSX.Element {\n  return createComponent(_Match, {\n    get when() {\n      return when();\n    },\n    //@ts-expect-error\n    children,\n  });\n}\n\n/**\n * Keyed Match component for use inside Switch. Renders children with keyed context if `when` is truthy.\n * @example\n * MatchKeyed(() => user(), user => html`<span>${user.name}</span>`)\n */\nexport function MatchKeyed<T>(\n  when: () => T,\n  children: ((item: NonNullable<T>) => JSX.Element)\n): JSX.Element {\n  return createComponent(_Match, {\n    get when() {\n      return when();\n    },\n    //@ts-expect-error\n    children,\n    keyed: true\n  });\n}\n\n/**\n * For component for iterating over arrays. Renders children for each item in `each`.\n * @example\n * For(() => items(), (item) => html`<li>${item}</li>`)\n */\nexport function For<T extends readonly any[]>(\n  each: () => T | false | null | undefined,\n  children: (item: T[number], index: () => number) => JSX.Element,\n  fallback?: ()=>JSX.Element\n): JSX.Element {\n  return createComponent(_For, {\n    get each() {\n      return each();\n    },\n    children,\n    get fallback() {\n      return fallback?.();\n    }\n  });\n}\n\n/**\n * Index component for iterating over arrays by index. Renders children for each item in `each`.\n * @example\n * Index(() => items(), (item, i) => html`<li>${item()}</li>`)\n */\nexport function Index<T extends readonly any[]>(\n  each: () => T | false | null | undefined,\n  children: (item: () => T[number], index: number) => JSX.Element,\n  fallback?: ()=>JSX.Element\n): JSX.Element {\n  return createComponent(_Index, {\n    get each() {\n      return each();\n    },\n    children,\n    get fallback() {\n      return fallback?.()\n    }\n  });\n}\n\n/**\n * Suspense component for async boundaries. Renders `children` or `fallback` while loading.\n * @example\n * Suspense(html`<div>Loaded</div>`, html`<div>Loading...</div>`)\n */\nexport function Suspense(\n  children: ()=>JSX.Element,\n  fallback?: ()=>JSX.Element\n): JSX.Element {\n  return createComponent(_Suspense, {\n    get children() {\n      return children()\n    },\n    get fallback() {\n      return fallback?.()\n    },\n  });\n}\n\n/**\n * ErrorBoundary component. Catches errors in children and renders `fallback` on error.\n * @example\n * ErrorBoundary(html`<App />`, (err) => html`<div>Error: ${err.message}</div>`)\n */\nexport function ErrorBoundary(\n  children: ()=>JSX.Element,\n  fallback: ((err: any, reset: () => void) => JSX.Element)\n): JSX.Element {\n  return createComponent(_ErrorBoundary, {\n    get children() {\n      return children()\n    },\n    fallback\n  });\n}\n\n/**\n * Context provider component. Provides a context value to all children.\n * @example\n * Context(MyContext, value, () => html`<Child />`)\n */\nexport function Context<T>(\n  context: _Context<T>,\n  value: T,\n  children: () => JSX.Element\n): JSX.Element {\n  return createComponent(context.Provider, {\n    get children() {\n      return children()\n    },\n    value\n  });\n}\n","import { MaybeFunction } from \"./types\";\n\nexport function isString(value: any): value is string {\n  return typeof value === \"string\";\n}\n\nexport function isFunction(value: any): value is Function {\n  return typeof value === \"function\";\n}\n\nexport function isArray(value: any): value is any[] {\n  return Array.isArray(value);\n}\n\nexport const toArray = Array.from;\n\n\nexport const doc = document\n\n","import {\n  addEventListener,\n  DelegatedEvents,\n  delegateEvents,\n  effect,\n  insert,\n} from \"solid-js/web\";\nimport { isFunction, isString } from \"./util\";\nimport { AssignmentRule } from \"./types\";\n\n\n\n\nexport function assignEvent(\n  node: Element,\n  name: string,\n  value: any,\n  prev?: any\n) {\n  prev && node.removeEventListener(name, prev);\n  value && node.addEventListener(name, value);\n  return value;\n}\n\nexport function assignDelegatedEvent(\n  node: Element,\n  name: string,\n  value: any,\n  prev?: any\n) {\n  name = name.toLowerCase()\n  let delegate = DelegatedEvents.has(name);\n  addEventListener(node, name, value, delegate);\n  if (delegate) delegateEvents([name]);\n  return value;\n}\n\nexport function assignProperty(\n  node: Element,\n  name: string,\n  value: any,\n  prev?: any\n) {\n  (node as any)[name] = value;\n  return value;\n}\n\nexport function assignBooleanAttribute(\n  node: Element,\n  name: string,\n  value: any,\n  prev?: any\n) {\n  if (value) {\n    node.setAttribute(name, \"\");\n  } else {\n    node.removeAttribute(name);\n  }\n  return value;\n}\n\nexport function assignAttribute(\n  node: Element,\n  name: string,\n  value: any,\n  prev?: any\n) {\n  if (value === null || value === undefined) {\n    node.removeAttribute(name);\n    return value;\n  }\n  node.setAttribute(name, value);\n  return value;\n}\n\nexport function assignAttributeNS(\n  namespace: string,\n  node: Element,\n  name: string,\n  value: any,\n  prev?: any,\n) {\n  if (value === null || value === undefined) {\n    node.removeAttributeNS(namespace, name);\n    return value;\n  }\n  node.setAttributeNS(namespace, name, value);\n  return value;\n}\n\nexport function assignClass(\n  node: Element,\n  name: string,\n  value: any,\n  prev?: any\n) {\n  node.classList.toggle(name, !!value);\n  return value;\n}\n\nexport function assignStyle(\n  node: Element,\n  name: string,\n  value: any,\n  prev?: any\n) {\n  (node as HTMLElement).style[name as any] = value ? value : \"\";\n  return value;\n}\n\n\nexport function assignRef(node: Element, name: string, value: any, prev?: any) {\n  if (isFunction(value)) {\n    value(node);\n  }\n}\n\nexport function assign(\n  rules: AssignmentRule[],\n  elem: Element,\n  name: string,\n  value: any,\n  prev?: any\n) {\n  if (value === prev) return value;\n  if (name === \"children\") {\n    return insert(elem, value);\n  }\n\n  for (const rule of rules) {\n    const { filter, assign, isReactive = true } = rule;\n    if (isString(filter) && name.startsWith(filter)) {\n      name = name.slice(filter.length);\n    } else if (isFunction(filter)) {\n      name = filter(elem, name, value, prev);\n    } else {\n      continue;\n    }\n    if (name) {\n      if (isFunction(value) && isReactive) {\n        effect(() => (prev = assign(elem, name, value(), prev)));\n      } else {\n        assign(elem, name, value, prev);\n      }\n      return prev;\n    }\n  }\n}\n\n\n\nexport function spread(\n  rules: AssignmentRule[],\n  elem: Element,\n  props: any,\n  prev: any = {}\n) {\n\n  if (isFunction(props)) {\n    effect(() => {\n      for (const [name, value] of Object.entries(props())) {\n        prev[name] = assign(rules, elem, name, value, prev[name]);\n      }\n    });\n  } else {\n    for (const [name, value] of Object.entries(props)) {\n      prev[name] = assign(rules, elem, name, value, prev[name]);\n    }\n  }\n  return prev;\n}\n\n","import { INode, IText, SyntaxKind, parse } from \"html5parser\";\nimport { insert, setAttribute } from \"solid-js/web\";\nimport { assign } from \"./assign\";\nimport { H, createElement } from \"./h\";\nimport { AssignmentRule, ComponentRegistry } from \"./types\";\nimport { doc, isFunction, isString, toArray } from \"./util\";\n\ntype TreeNode = TextNode | ComponentNode | ElementNode | InsertNode | CommentNode\n\ntype ValueParts = Array<string | number>\n\ntype Property = [name: string, value: ValueParts]\n\ntype TextNode = {\n  type: \"text\"\n  value: string\n}\n\ntype CommentNode = {\n  type: \"comment\"\n  value: string\n}\n\ntype InsertNode = {\n  type: \"insert\"\n  value: number\n}\n\ntype ComponentNode = {\n  type: \"component\"\n  name: string\n  props: Property[]\n  children: TreeNode[]\n  template?: HTMLTemplateElement\n}\n\ntype ElementNode = {\n  type: \"element\"\n  name: string\n  props: Property[]\n  children: TreeNode[],\n}\n\ntype RootNode = {\n  type: \"root\"\n  children: TreeNode[]\n  template?: HTMLTemplateElement\n}\n\n//Should be unique character that would never be in the template literal\nconst marker = '⧙⧘';\n\n\n//Captures index of hole\nconst match = new RegExp(`${marker}(\\\\d+)${marker}`, \"g\")\n\nconst cache = new WeakMap<TemplateStringsArray, RootNode>();\nconst walker = doc.createTreeWalker(doc, 133);\n\n\nfunction getCachedRoot(strings: TemplateStringsArray): RootNode {\n  let root = cache.get(strings);\n  if (!root) {\n    //join string with markers and index    \n    const ast = parse(strings.slice(1).reduce((prev, current, index) => prev + marker + index + marker + current, strings[0]))\n    const children = ast.flatMap(n => parseNode(n))\n\n    const template = buildTemplate(children)\n    root = {\n      type: \"root\",\n      children,\n      template\n    }\n\n    cache.set(strings, root);\n  }\n  return root;\n}\n\nfunction flat(arr: any[]) {\n  return (arr.length === 1 ? arr[0] : arr);\n}\n\nfunction getValue(value: any) {\n  while (isFunction(value)) value = value();\n  return value;\n}\n\n\nexport function HTML(components: ComponentRegistry = {}, rules: AssignmentRule[] = [], clone = true) {\n  function html(strings: TemplateStringsArray, ...values: any[]) {\n    const cached = getCachedRoot(strings);\n\n    function renderTemplate(template: HTMLTemplateElement, componentNode: ComponentNode | RootNode) {\n      const clone = template.content.cloneNode(true)\n      walker.currentNode = clone;\n      walkNodes(componentNode.children)\n\n      function walkNodes(nodes: TreeNode[]) {\n        nodes.forEach(node => {\n          const domNode = walker.nextNode()!;\n          if (node.type === \"element\") {\n            for (const [name, parts] of node.props) {\n              // if (parts.length===1 && isString(parts[0])) continue\n              const value = substituteValues(parts, values);\n              assign(html.h.rules, domNode as Element, name, value.length === 1 ? value[0] : () => value.map(getValue).join(\"\"))\n            }\n            walkNodes(node.children)\n          } else if (node.type === \"insert\" || node.type === \"component\") {\n            insert(domNode.parentNode!, renderNode(node), domNode)\n            walker.currentNode = domNode\n          }\n        })\n      }\n      return toArray(clone.childNodes)\n    }\n\n    function renderNode(node: TreeNode): any {\n      if (node.type === \"text\") {\n        return node.value\n      } else if (node.type === \"insert\") {\n        return values[node.value]\n      } else if (node.type === \"comment\") {\n        return doc.createComment(node.value)\n      }\n\n      // gather props\n      const props = {} as Record<string, any>;\n      for (let [name, parts] of node.props) {\n        const value = substituteValues(parts, values);\n        props[name] = value.length === 1 ? value[0] : () => value.map(getValue)\n      }\n\n      // children - childNodes overwrites any props.children\n      if (node.children.length) {\n        if (node.type === \"component\" && node.template && clone) {\n          props.children = () => renderTemplate(node.template!, node)\n        } else {\n          props.children = () => flat(node.children.map(renderNode));\n        }\n      }\n\n      return html.h(node.name, props);\n    }\n\n    if (cached.template && clone) {\n      // const r = renderTemplate(cached.template, cached)\n      // performance.mark(\"render-template\")\n      // return r\n      return renderTemplate(cached.template, cached)\n    }\n\n    // const r = flat(cached.children.map(renderNode));\n    // performance.mark(\"render-node\")\n    // return r\n    return flat(cached.children.map(renderNode));\n  }\n\n  html.h = H(components, rules);\n\n  return html;\n}\n\n\n\n\nfunction substituteValues(parts: ValueParts, values: any[]) {\n  return parts.map(v => isString(v) ? v : values[v])\n}\n\n//Split by marker and extract index of hole. Remove empty strings \nfunction parseValue(value: string = \"\"): ValueParts {\n  return value.split(match).map((v, i) => (i % 2 === 1 ? Number(v) : v)).filter(v => !isString(v) || v.trim())\n}\n\n\n//Parse html5parser result for what we care about\nfunction parseNode(node: INode): TreeNode | TreeNode[] {\n\n  //Text nodes are either static text or holes to insert in\n  if (node.type === SyntaxKind.Text) {\n    const parts = parseValue(node.value)\n    return parts.map(value => {\n      const type = isString(value) ? \"text\" : \"insert\"\n      return {\n        type,\n        value,\n      } as InsertNode | TextNode\n    })\n  }\n\n\n  if (node.name[0] === \"!\" || node.name === \"\") {\n    return {\n      type: \"comment\",\n      value: (node.body as IText[])[0].value\n    } as CommentNode\n  }\n\n  const props = node.attributes.map(v => [v.name.value, parseValue(v.value?.value)]) as Property[]\n  const children = node.body?.flatMap((n) => parseNode(n)) ?? []\n\n  if (/^[A-Z]/.test(node.rawName)) {\n    return {\n      type: \"component\",\n      name: node.rawName,\n      props,\n      children,\n      template: buildTemplate(children)\n    } as ComponentNode\n  }\n\n  return {\n    type: \"element\",\n    name: node.name,\n    props,\n    children,\n  } as ElementNode\n}\n\n\n//build template element with same exact shape as tree so they can be walked through in sync\nfunction buildTemplate(nodes: TreeNode[]): HTMLTemplateElement | undefined {\n  //Criteria for using template is component or root has at least 1 element. May be be a more optimal condition.\n  if (nodes.some((v) => v.type === \"element\")) {\n    const template = doc.createElement(\"template\")\n    buildNodes(nodes, template.content)\n    return template\n  }\n}\n\n\nfunction buildNodes(nodes: TreeNode[], parent: Node,) {\n  nodes.forEach((node, i) => {\n    if (node.type === \"text\") {\n      parent.appendChild(doc.createTextNode(node.value))\n    } else if (node.type === \"comment\") {\n      parent.appendChild(doc.createComment(node.value))\n    } else if (node.type === \"insert\") {\n      parent.appendChild(doc.createComment(node.type))\n    } else if (node.type === \"component\") {\n      parent.appendChild(doc.createComment(node.name))\n    } else if (node.type === \"element\") {\n      const elem = createElement(node.name)\n      parent.appendChild(elem)\n      // node.props.forEach((([name,value])=>{\n      //   if (value.length===1 &&  isString(value[0])){\n      //     setAttribute(elem,name,value[0])\n      //   }\n      // }))\n      buildNodes(node.children, elem)\n    }\n  })\n}\n\nfunction writeNodes(nodes: TreeNode[]): string {\n  return nodes.map((node, i) => {\n    if (node.type === \"text\") {\n      return node.value\n    } else if (node.type === \"comment\") {\n      return `<!--${node.value}-->`\n    } else if (node.type === \"insert\") {\n      return `<!--${node.type}-->`\n    } else if (node.type === \"component\") {\n      return `<!--${node.name}-->`\n    } else if (node.type === \"element\") {\n      return `<${node.name}>${writeNodes(node.children)}</${node.name}>`\n    }\n  }).join(\"\")\n}\n\n","import {\n  Dynamic,\n  ErrorBoundary,\n  For,\n  Index,\n  Match,\n  NoHydration,\n  Portal,\n  Show,\n  Suspense,\n  Switch,\n} from \"solid-js/web\";\nimport {\n  assignAttribute,\n  assignBooleanAttribute,\n  assignClass,\n  assignDelegatedEvent,\n  assignEvent,\n  assignProperty,\n  assignRef,\n  assignStyle\n} from \"./assign\";\nimport { H } from \"./h\";\nimport { HTML } from \"./html\";\nimport { AssignmentRule, ComponentRegistry } from \"./types\";\n\n\n\nexport const defaultRules: AssignmentRule[] = [\n  { filter: \"on:\", assign: assignEvent, isReactive: false },\n  { filter: \"on\", assign: assignDelegatedEvent, isReactive: false },\n  { filter: \"prop:\", assign: assignProperty },\n  { filter: \"bool:\", assign: assignBooleanAttribute },\n  { filter: \"attr:\", assign: assignAttribute },\n  { filter: \"ref:\", assign: assignRef, isReactive: false },\n  { filter: \"class:\", assign: assignClass },\n  { filter: \"style:\", assign: assignStyle },\n  { filter: \"@\", assign: assignDelegatedEvent, isReactive: false },\n  { filter: \".\", assign: assignProperty },\n  { filter: \"?\", assign: assignBooleanAttribute },\n  { filter: \"\", assign: assignAttribute } //default\n]\n\n\n\nexport const defaultComponents: ComponentRegistry = {\n  For,\n  Index,\n  Match,\n  Suspense,\n  ErrorBoundary,\n  Show,\n  Switch,\n  Dynamic,\n  Portal,\n  NoHydration,\n}\n\nexport const xmlNamespaces = [\"on\", \"prop\", \"bool\", \"attr\", \"ref\", \"style\", \"class\", \"xlink\"]\n\n\nexport const h = H();\n\nexport const html = HTML()\n//link global xml with global h\nhtml.h = h\n\n","import {\n  createComponent,\n  type ComponentProps,\n  type JSX,\n  type ValidComponent,\n} from \"solid-js\";\n\nimport { spread } from \"./assign\";\nimport { defaultComponents, defaultRules } from \"./defaults\";\n\nimport { doc, isFunction, isString } from \"./util\";\nimport { SVGElements } from \"solid-js/web\";\nimport { AssignmentRule, MaybeFunctionProps } from \"./types\";\n\nexport function H(components: Record<string, any> = {}, rules: AssignmentRule[] = []) {\n\n  function h<T extends ValidComponent>(\n    component: T,\n    props: MaybeFunctionProps<ComponentProps<T>>,\n    ...children: JSX.Element[]\n  ): JSX.Element {\n    //children in spread syntax override children in props\n    if (children.length === 1) {\n      //@ts-expect-error\n      props.children = children[0];\n    } else if (children.length > 1) {\n      //@ts-expect-error\n      props.children = children;\n    }\n\n    if (isFunction(component)) {\n      return createComponent(component, wrapProps(props));\n    }\n\n    if (isString(component)) {\n      const componentFunction = (h.components)[component];\n      if (componentFunction) {\n        return createComponent(componentFunction, wrapProps(props));\n      }\n      \n      if (/[A-Z]/.test(component)) {\n        console.warn(`Forgot to define ${componentFunction}`);\n      }\n\n      const elem = createElement(component)\n      spread(h.rules, elem, props);\n      return elem;\n    } \n  }\n  \n  h.components = {...defaultComponents, ...components};\n  h.define = (components: Record<string, ValidComponent>) => {\n    Object.assign(h.components, components);\n  };\n  h.rules = [...rules, ...defaultRules];\n\n\n  return h;\n\n}\n\nconst elementCache = new Map<string,Element>()\nconst CommentNode = Symbol(\"CommentNode\")\n\nexport function createElement(tag: string){\n  return SVGElements.has(tag) ? doc.createElementNS(\"http://www.w3.org/2000/svg\", tag) : doc.createElement(tag)\n}\n\nexport const markedOnce = new WeakSet();\n\n/**\n * Marks a function so it is not wrapped as a getter by h().\n * Useful for event handlers or functions that should not be auto-accessed.\n * @example\n * once(() => doSomething())\n */\nexport function once<T extends (...args: any[]) => any>(fn: T): T {\n  if (isFunction(fn)) markedOnce.add(fn);\n  return fn;\n}\n\n/**\n * Internal: Replaces accessor props with getters for reactivity, except for refs and event handlers.\n */\nexport function wrapProps<\n  TComponent extends ValidComponent,\n  TProps extends MaybeFunctionProps<ComponentProps<TComponent>>\n>(props: TProps = {} as TProps): ComponentProps<TComponent> {\n  for (const [key, descriptor] of Object.entries(\n    Object.getOwnPropertyDescriptors(props)\n  )) {\n    const value = descriptor.value;\n    if (isFunction(value) && value.length === 0 && !markedOnce.has(value)) {\n      Object.defineProperty(props, key, {\n        get() {\n          return value();\n        },\n        enumerable: true,\n      });\n    }\n  }\n  return props as ComponentProps<TComponent>;\n}\n"],"mappings":"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"}