{"version":3,"file":"index.mjs","names":["value: any","data:string","tag: string","arr: any[]","input: TemplateStringsArray","html5parse","nodes: INode[]","node: INode","name","value: string","node: RootNode | ChildNode","node: ChildNode","components: T","sld","strings: TemplateStringsArray","newComponents: TNew","node: ChildNode","values: any[]","components: ComponentRegistry","node: ComponentNode | RootNode | ElementNode","nodes: ChildNode[]","node","node: ElementNode | ComponentNode","props: Record<string, any>","spread","name: string","value: any","component: T"],"sources":["../src/util.ts","../src/parse.ts","../src/template.ts","../src/sld.ts","../src/index.ts"],"sourcesContent":["import { SVGElements } from \"solid-js/web\";\n\n\nexport function isString(value: any): value is string {\n  return typeof value === \"string\";\n}\n\nexport function isNumber(value: any): value is number {\n  return typeof value === \"number\";\n}\n\nexport function isFunction(value: any): value is Function {\n  return typeof value === \"function\";\n}\n\nexport function isBoolean(value: any): value is boolean {\n  return typeof value === \"boolean\";\n}\n\nexport function isObject(value: any): value is object {\n  return typeof value === \"object\";\n}\n\nexport function isArray(value: any): value is any[] {\n  return Array.isArray(value);\n}\n\nexport const toArray = Array.from;\n\n\nexport const doc = document\n\nexport const createComment = (data:string)=>doc.createComment(data)\n\nexport function createElement(tag: string){\n  return SVGElements.has(tag) ? doc.createElementNS(\"http://www.w3.org/2000/svg\", tag) : doc.createElement(tag)\n}\n\nexport function flat(arr: any[]) {\n  return (arr.length === 1 ? arr[0] : arr);\n}\n\nexport function getValue(value: any) {\n  while (isFunction(value)) value = value();\n  return value;\n}","import {\n    SyntaxKind,\n    parse as html5parse,\n    type INode,\n    type IText\n} from \"html5parser\";\n\nimport { isNumber, isString } from \"./util\";\n\n\n//AST Node types\n\n//Non reactive text\nexport const TEXT_NODE = 1;\nexport type TextNode = {\n    type: typeof TEXT_NODE;\n    value: string;\n};\n\n//Non reactive Comment Node <!--value-->\nexport const COMMENT_NODE = 2;\nexport type CommentNode = {\n    type: typeof COMMENT_NODE;\n    value: string;\n};\n\n//Reactive Hole\nexport const INSERT_NODE = 3;\nexport type InsertNode = {\n    type: typeof INSERT_NODE;\n    value: number; //index of hole\n};\n\n//tag with lowercase first letter <div />\nexport const ELEMENT_NODE = 4;\nexport type ElementNode = {\n    type: typeof ELEMENT_NODE;\n    name: string;\n    props: Property[];\n    children: ChildNode[];\n};\n\n//Tag with capital first letter <Div />\nexport const COMPONENT_NODE = 5;\nexport type ComponentNode = {\n    type: typeof COMPONENT_NODE;\n    name: string;\n    props: Property[];\n    children: ChildNode[];\n    template?: HTMLTemplateElement\n};\n\nexport const ROOT_NODE = 6;\nexport type RootNode = {\n    type: typeof ROOT_NODE;\n    children: ChildNode[];\n    template?: HTMLTemplateElement\n};\n\nexport type ChildNode =\n    | TextNode\n    | ComponentNode\n    | ElementNode\n    | InsertNode\n    | CommentNode;\n\nexport type Property = BooleanProperty | StringProperty | DynamicProperty | MixedProperty | SpreadProperty | AnonymousProperty\n\n// <input disabled>\nexport const BOOLEAN_PROPERTY = 1\nexport type BooleanProperty = {\n    type: typeof BOOLEAN_PROPERTY\n    name: string,\n}\n\n// <input value=\"myString\"> <input value='myString'> <input value=\"\"> <input value=''>\nexport const STRING_PROPERTY = 2\nexport type StringProperty = {\n    type: typeof STRING_PROPERTY\n    name: string,\n    value: string\n}\n\n// <input value=${}> <input value=\"${}\"\"> <input value='${}'>\nexport const DYNAMIC_PROPERTY = 3\nexport type DynamicProperty = {\n    type: typeof DYNAMIC_PROPERTY\n    name: string,\n    value: number\n}\n\n// <input value=\" ${}\"> <input value=\"input-${}\"> <input value='${\"value1\"} ${\"value2\"}'>\nexport const MIXED_PROPERTY = 4\nexport type MixedProperty = {\n    type: typeof MIXED_PROPERTY\n    name: string,\n    value: Array<string | number>\n}\n\n// <input ...${} />\nexport const SPREAD_PROPERTY = 5\nexport type SpreadProperty = {\n    type: typeof SPREAD_PROPERTY\n    value: number\n}\n\n// <input ${} />\nexport const ANONYMOUS_PROPERTY = 6\nexport type AnonymousProperty = {\n    type: typeof ANONYMOUS_PROPERTY\n    value: number\n}\n\n//string or boolean means static, number means hole and is index, array means mix of string and holes\nexport type ValueParts = string | boolean | number | Array<string | number>;\n\n//Needs to be unique character that would never be in the template literal\nconst marker = \"⧙⧘\";\n\n//Captures index of hole\nconst match = new RegExp(`${marker}(\\\\d+)${marker}`, \"g\");\n\n/**\n * \n * @param input jsx like string to parse\n * @returns RootNode of an AST\n */\nexport function parse(input: TemplateStringsArray): RootNode {\n    const ast = html5parse(\n        input\n            .slice(1)\n            .reduce(\n                (prev, current, index) => prev + marker + index + marker + current,\n                input[0],\n            ),\n    );\n    return {\n        type: ROOT_NODE,\n        children: parseNodes(ast)\n    }\n}\n\nfunction parseNodes(nodes: INode[]) {\n    return nodes.flatMap(parseNode)\n}\n//Parse html5parser result for what we care about\nfunction parseNode(\n    node: INode,\n): ChildNode | ChildNode[] {\n    //Text nodes are either static text or holes to insert in\n    if (node.type === SyntaxKind.Text) {\n        return node.value\n            .split(match).flatMap((value, index, array) => {\n                if (index % 2 === 1) {\n                    return {\n                        type: INSERT_NODE,\n                        value: Number(value)\n                    }\n                }\n                //We want to trim when only content in textnode is the hole or if textnode is empty\n                if (!value || (array.length === 3 && !value.trim())) {\n                    return []\n                }\n\n                return {\n                    type: TEXT_NODE,\n                    value,\n                }\n            });\n    }\n\n    //html5parser represents comments as type tag with name \"!\" or \"\"\n    if (node.name[0] === \"!\" || node.name === \"\") {\n        return {\n            type: COMMENT_NODE,\n            value: (node.body as IText[]).join(\"\"),\n        } as CommentNode;\n    }\n\n    const props = node.attributes.flatMap((v) => {\n        const nameParts = getParts(v.name.value);\n\n        if (nameParts.length === 1) {\n            const name = nameParts[0];\n            if (v.value === undefined) {\n                return {\n                    name,\n                    type: BOOLEAN_PROPERTY\n                }\n            }\n\n            if (isNumber(name)) {\n                return {\n                    type: ANONYMOUS_PROPERTY,\n                    value: nameParts[1]\n                }\n            }\n\n            const valueParts = getParts(v.value?.value);\n\n            if (valueParts.length === 0) {\n                return {\n                    name,\n                    type: BOOLEAN_PROPERTY\n                }\n            } else if (valueParts.length === 1) {\n                const value = valueParts[0]\n                if (isNumber(value)) {\n                    return {\n                        type: DYNAMIC_PROPERTY,\n                        name,\n                        value\n                    }\n                } else {\n                    return {\n                        type: STRING_PROPERTY,\n                        name,\n                        value\n                    }\n                }\n            } else {\n                return {\n                    type: MIXED_PROPERTY,\n                    name,\n                    value: valueParts\n                }\n            }\n        }\n\n        //name is mixed static and dynamic. We only look for ...${}\n        if (nameParts[0] === \"...\") {\n            return {\n                type: SPREAD_PROPERTY,\n                value: nameParts[1]\n            }\n        }\n\n        return []\n    }) as Property[];\n\n    const children = node.body?.flatMap(parseNode) ?? [];\n    const name = node.rawName as string;\n\n    return {\n        type: /^[A-Z]/.test(name) ? COMPONENT_NODE : ELEMENT_NODE,\n        name,\n        props,\n        children,\n    };\n}\n\nfunction getParts(value: string = \"\"): Array<string | number> {\n    return value\n        .split(match)\n        .map((v, i) => (i % 2 === 1 ? Number(v) : v))\n        .filter((v) => isNumber(v) || !v);\n}","import { COMMENT_NODE, COMPONENT_NODE, ELEMENT_NODE, INSERT_NODE, TEXT_NODE, ChildNode, RootNode, ComponentNode, ROOT_NODE, STRING_PROPERTY, BOOLEAN_PROPERTY } from \"./parse\";\nimport { createComment, createElement, isString } from \"./util\";\n\n\n\n\n//build template element with same exact shape as tree so they can be walked through in sync\nexport function buildTemplate(node: RootNode | ChildNode): void {\n    if (node.type === ROOT_NODE || node.type === COMPONENT_NODE) {\n        //Criteria for using template is component or root has at least 1 element. May be be a more optimal condition.\n        if (node.children.some((v) => v.type === ELEMENT_NODE)) {\n            const template = document.createElement(\"template\");\n            // buildNodes(node.children, template.content);\n            template.innerHTML = node.children.map(buildHTML).join(\"\");\n            node.template = template\n        }\n        node.children.forEach(buildTemplate)\n    }\n    if (node.type === ELEMENT_NODE) {\n        node.children.forEach(buildTemplate)\n    }\n}\n\n\n//Lets browser handle svg,mathml, and html encoding\nfunction buildHTML(node: ChildNode): string {\n    switch (node.type) {\n        case TEXT_NODE:\n            return node.value;\n        case COMMENT_NODE:\n            return `<!--${node.value}-->`;\n        case INSERT_NODE:\n            return `<!--+-->`;\n        case COMPONENT_NODE:\n            return `<!--${node.name}-->`;\n        case ELEMENT_NODE:\n            let attributeHTML=\"\"\n            node.props = node.props.filter((prop) => {\n                if (prop.type === STRING_PROPERTY) {\n                    attributeHTML+=` ${prop.name}=\"${prop.value}\"`\n                    return;\n                } else if (prop.type===BOOLEAN_PROPERTY) {\n                    attributeHTML+=` ${prop.name}`\n                    return;\n                }\n                return true;\n            });\n\n\n            return `<${node.name}${attributeHTML}>${node.children.map(buildHTML).join(\"\")}</${node.name}>`;\n    }\n}\n\n//Building manually requires checking for MathML, SVG tags as well as html encoded chars\nfunction buildNodes(nodes: ChildNode[], parent: Node) {\n    for (const node of nodes) {\n        switch (node.type) {\n            case TEXT_NODE:\n                parent.appendChild(document.createTextNode(node.value));\n                break;\n            case COMMENT_NODE:\n                parent.appendChild(createComment(node.value));\n                break;\n            case INSERT_NODE:\n                parent.appendChild(createComment(\"+\"));\n                break;\n            case COMPONENT_NODE:\n                parent.appendChild(createComment(node.name));\n                break;\n            case ELEMENT_NODE:\n                const elem = createElement(node.name);\n                parent.appendChild(elem);\n\n                //set static attributes only and remove from props\n                node.props = node.props.filter((prop) => {\n                    if (prop.type === STRING_PROPERTY) {\n                        elem.setAttribute(prop.name, prop.value);\n                        return;\n                    } else if (prop.type===BOOLEAN_PROPERTY) {\n                        elem.setAttribute(prop.name, \"\"); //boolean attribute\n                        return;\n                    }\n                    return true;\n                });\n                buildNodes(node.children, elem);\n                break;\n        }\n    }\n}\n\n","import { JSX, createComponent, mergeProps } from \"solid-js\";\nimport { SVGElements, insert, spread } from \"solid-js/web\";\nimport {\n  ANONYMOUS_PROPERTY,\n  BOOLEAN_PROPERTY,\n  COMMENT_NODE,\n  COMPONENT_NODE,\n  ChildNode,\n  ComponentNode,\n  DYNAMIC_PROPERTY,\n  ELEMENT_NODE,\n  ElementNode,\n  INSERT_NODE,\n  MIXED_PROPERTY,\n  ROOT_NODE,\n  RootNode,\n  SPREAD_PROPERTY,\n  STRING_PROPERTY,\n  TEXT_NODE,\n  parse,\n} from \"./parse\";\nimport { buildTemplate } from \"./template\";\nimport { ComponentRegistry, SLDInstance } from \"./types\";\nimport {\n  createComment,\n  createElement,\n  flat,\n  getValue,\n  isFunction,\n  isNumber,\n  isObject,\n  toArray\n} from \"./util\";\n\nconst cache = new WeakMap<TemplateStringsArray, RootNode>();\n\n//Walk over text, comment, and element nodes\nconst walker = document.createTreeWalker(document, 133);\n\n\n\nexport function createSLD<T extends ComponentRegistry>(components: T): SLDInstance<T> {\n  function sld(strings: TemplateStringsArray, ...values: any[]) {\n    const root = getCachedRoot(strings);\n\n    return renderChildren(root, values, components);\n  }\n  sld.components = components;\n  sld.sld = sld;\n  sld.define = function define<TNew extends ComponentRegistry>(\n    newComponents: TNew\n  ) {\n    return createSLD({ ...components, ...newComponents });\n  };\n\n\n  return sld as SLDInstance<T>;\n}\n\nfunction getCachedRoot(strings: TemplateStringsArray): RootNode {\n  let root = cache.get(strings);\n  if (!root) {\n    root = parse(strings);\n    buildTemplate(root);\n    cache.set(strings, root);\n    // console.log(root)\n  }\n  return root;\n}\n\nfunction renderNode(\n  node: ChildNode,\n  values: any[],\n  components: ComponentRegistry\n): any {\n  switch (node.type) {\n    case TEXT_NODE:\n      return node.value;\n    case INSERT_NODE:\n      return values[node.value];\n    case COMMENT_NODE:\n      return createComment(node.value);\n    case ELEMENT_NODE:\n      const element = createElement(node.name);\n      spread(\n        element,\n        gatherProps(node, values, components),\n        SVGElements.has(node.name),\n        true\n      );\n      return element;\n    case COMPONENT_NODE:\n      const component = components[node.name];\n      if (!component) throw new Error(`${node.name} is not defined`);\n      return createComponent(component, gatherProps(node, values, components));\n  }\n}\n\nfunction renderChildren(\n  node: ComponentNode | RootNode | ElementNode,\n  values: any[],\n  components: ComponentRegistry\n): JSX.Element {\n  const template =\n    (node.type === ROOT_NODE || node.type === COMPONENT_NODE) && node.template;\n  if (!template) {\n    return flat(node.children.map((n) => renderNode(n, values, components)));\n  }\n\n  const clone = template.content.cloneNode(true);\n  walker.currentNode = clone;\n  walkNodes(node.children);\n\n  function walkNodes(nodes: ChildNode[]) {\n    for (const node of nodes) {\n      const domNode = walker.nextNode()!;\n      if (node.type === ELEMENT_NODE) {\n        if (node.props.length) {\n          //Assigning props to element via assign prop w/effect may be better for performance.\n          const props = gatherProps(node, values, components);\n          spread(domNode as Element, props, SVGElements.has(node.name), true);\n        }\n\n        walkNodes(node.children);\n      } else if (node.type === INSERT_NODE || node.type === COMPONENT_NODE) {\n        insert(\n          domNode.parentNode!,\n          renderNode(node, values, components),\n          domNode\n        );\n        walker.currentNode = domNode;\n      }\n    }\n  }\n  return toArray(clone.childNodes);\n}\n\nfunction gatherProps(\n  node: ElementNode | ComponentNode,\n  values: any[],\n  components: ComponentRegistry,\n  props: Record<string, any> = {}\n) {\n  for (const prop of node.props) {\n    switch (prop.type) {\n\n      case BOOLEAN_PROPERTY:\n        props[prop.name] = true;\n        break;\n      case STRING_PROPERTY:\n        props[prop.name] = prop.value\n        break;\n      case DYNAMIC_PROPERTY:\n        applyGetter(props, prop.name, values[prop.value])\n        break;\n      case MIXED_PROPERTY:\n        const value = () =>\n          prop.value\n            .map((v) => (isNumber(v) ? getValue(values[v]) : v))\n            .join(\"\");\n        applyGetter(props, prop.name, value);\n        break;\n      case SPREAD_PROPERTY:\n        const spread = values[prop.value];\n        if (!isObject(spread)) throw new Error(\"Can only spread objects\");\n        props = mergeProps(props, spread);\n        break;\n      case ANONYMOUS_PROPERTY:\n        props.ref = values[prop.value];\n        break;\n    }\n  }\n\n  // children - childNodes overwrites any props.children\n  if (node.children.length) {\n    Object.defineProperty(props, \"children\", {\n      get() {\n        return renderChildren(node, values, components);\n      },\n    });\n  }\n  return props;\n}\n\n\nfunction applyGetter(props: Record<string, any>, name: string, value: any) {\n  if (\n    isFunction(value) &&\n    value.length === 0 &&\n    name !== \"ref\" &&\n    !name.startsWith(\"on\")\n  ) {\n    Object.defineProperty(props, name, {\n      get() {\n        return value();\n      },\n      enumerable: true,\n    });\n  } else {\n    props[name] = value;\n  }\n}","import { createComponent, ErrorBoundary, For, Index, Match, Show, Suspense, Switch } from \"solid-js\";\nimport { createSLD, } from \"./sld\";\nimport { type FunctionComponent, type SLDInstance } from \"./types\";\n\nexport { parse } from \"./parse\";\nexport { createSLD, SLDInstance };\n\nexport const defaultComponents = {\n    For,\n    Index,\n    Match,\n    Suspense,\n    ErrorBoundary,\n    Show,\n    Switch,\n};\n\n\nexport const sld = createSLD(defaultComponents)\nexport const SLD = sld.define\n\nexport default sld\n\n/**\n * Helper function for giving better typescript to components. Wrap in createComponent but keep same signature of function. Helps for overlaods.\n * @param component Function of component\n * @returns \n */\nexport function run<T extends FunctionComponent>(component: T): T {\n    //@ts-expect-error\n    return (props)=>createComponent(component, props)\n}"],"mappings":"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"}