{"version":3,"file":"index.mjs","names":["value: any","node: Element","name: string","value: any","prev?: any","defaultRules: AssignmentRules","rules: AssignmentRules","elem: Element","props: any","props: Record<string, any>","rules: AssignmentRules","h","component: T","props: MaybeFunctionProps<ComponentProps<T>>","fn: T","props: TProps","when: () => boolean","children: MaybeFunction<JSX.Element>","fallback?: MaybeFunction<JSX.Element>","_Show","when: () => T","children: JSX.Element | ((item: NonNullable<T>) => JSX.Element)","fallback: MaybeFunction<JSX.Element>","_Switch","when: () => T | undefined | null | false","children: JSX.Element | ((item: T) => JSX.Element)","_Match","each: () => T | false | null | undefined","children: (item: T[number], index: () => number) => JSX.Element","_For","children: (item: () => T[number], index: number) => JSX.Element","_Index","_Suspense","fallback:\r\n    | MaybeFunction<JSX.Element>\r\n    | ((err: any, reset: () => void) => JSX.Element)","_ErrorBoundary","context: _Context<T>","value: T | (() => T)","children: () => JSX.Element","marker","strings: TemplateStringsArray","type: ResultType","attrNames: Array<string>","html","rawTextEndRegex: RegExp | undefined","attrName: string | undefined","match!: RegExpExecArray | null","htmlResult: string","strings: TemplateStringsArray","type: ResultType","html","rules: AssignmentRules","value: any","marker","strings","strings: TemplateStringsArray","xml","arr: any","value: any","jsx: ReturnType<typeof XML>","cached: NodeList","values: any[]","rules: AssignmentRules","h","node: any","x: string","components: Record<string, any>","template: TemplateStringsArray","userComponents: Record<string, any>"],"sources":["../src/util.ts","../src/assign.ts","../src/h.ts","../src/components.ts","../src/lit-html.ts","../src/html.ts","../src/xml.ts"],"sourcesContent":["export function isString(value: any): value is string {\r\n  return typeof value === \"string\";\r\n}\r\n\r\nexport function isFunction(value: any): value is Function {\r\n  return typeof value === \"function\";\r\n}\r\n\r\nexport const doc = document\r\n\r\n","import {\r\n  addEventListener,\r\n  DelegatedEvents,\r\n  delegateEvents,\r\n  effect,\r\n  insert,\r\n} from \"solid-js/web\";\r\nimport { isFunction } from \"./util\";\r\nimport { markedOnce } from \"./h\";\r\n\r\nexport type AssignmentFunction = (\r\n  node: Element,\r\n  name: string,\r\n  value: any,\r\n  prev: any\r\n) => any;\r\n\r\nexport type AssignmentRule = [string, AssignmentFunction];\r\nexport type AssignmentRules = Array<AssignmentRule>;\r\n\r\nexport function assignEvent(\r\n  node: Element,\r\n  name: string,\r\n  value: any,\r\n  prev?: any\r\n) {\r\n  node.addEventListener(name, value);\r\n}\r\n\r\nexport function assignDelegatedEvent(\r\n  node: Element,\r\n  name: string,\r\n  value: any,\r\n  prev?: any\r\n) {\r\n  let delegate = DelegatedEvents.has(name);\r\n  addEventListener(node, name, value, delegate);\r\n  if (delegate) delegateEvents([name]);\r\n}\r\n\r\nexport function assignProperty(\r\n  node: Element,\r\n  name: string,\r\n  value: any,\r\n  prev?: any\r\n) {\r\n  node[name] = value;\r\n}\r\n\r\nexport function assignBooleanAttribute(\r\n  node: Element,\r\n  name: string,\r\n  value: any,\r\n  prev?: any\r\n) {\r\n  if (value) {\r\n    node.setAttribute(name, \"\");\r\n  } else {\r\n    node.removeAttribute(name);\r\n  }\r\n}\r\n\r\nexport function assignAttribute(\r\n  node: Element,\r\n  name: string,\r\n  value: any,\r\n  prev?: any\r\n) {\r\n  node.setAttribute(name, value);\r\n}\r\n\r\nexport function assignRef(node: Element, name: string, value: any, prev?: any) {\r\n  if (isFunction(value)) {\r\n    value(node);\r\n  }\r\n}\r\n\r\nexport const defaultRules: AssignmentRules = [\r\n  [\"on:\", assignEvent],\r\n  [\"prop:\", assignProperty],\r\n  [\"bool:\", assignBooleanAttribute],\r\n  [\"attr:\", assignAttribute],\r\n  [\"ref:\", assignRef],\r\n];\r\n\r\n/**\r\n * Assigns a property, attribute, boolean, or event handler to an element, supporting reactivity.\r\n * @internal\r\n */\r\nexport function assign(\r\n  rules: AssignmentRules,\r\n  elem: Element,\r\n  name: string,\r\n  value: any,\r\n  prev?: any\r\n) {\r\n  for (const [prefix, assignFn] of rules) {\r\n    if (name.startsWith(prefix)) {\r\n      elem.removeAttribute(name); // Remove the original attribute to prevent conflicts\r\n      name = name.slice(prefix.length);\r\n      if (isFunction(value) && !markedOnce.has(value)) {\r\n        effect(() => (prev = assignFn(elem, name, value, prev)));\r\n      } else {\r\n        assignFn(elem, name, value, prev);\r\n      }\r\n\r\n      return;\r\n    }\r\n  }\r\n  // If no syntax matched, default to setting the attribute\r\n  assignAttribute(elem, name, value);\r\n}\r\n\r\nexport function spread(\r\n  rules: AssignmentRules,\r\n  elem: Element,\r\n  props: any,\r\n  prev?: any\r\n) {\r\n  if (isFunction(props) && !markedOnce.has(props)) {\r\n    effect(() => {\r\n      spreadProps(rules, elem, props());\r\n    });\r\n  } else {\r\n    spreadProps(rules, elem, props);\r\n  }\r\n}\r\n\r\nfunction spreadProps(\r\n  rules: AssignmentRules,\r\n  elem: Element,\r\n  props: Record<string, any>\r\n) {\r\n  for (const [name, value] of Object.entries(props)) {\r\n    if (name === \"children\") {\r\n      insert(elem, value);\r\n    } else {\r\n      assign(rules, elem, name, value);\r\n    }\r\n  }\r\n}\r\n","import {\r\n  createComponent,\r\n  type ComponentProps,\r\n  type JSX,\r\n  type ValidComponent,\r\n} from \"solid-js\";\r\nimport { doc, isFunction, isString } from \"./util\";\r\nimport { AssignmentRules, defaultRules, spread } from \"./assign\";\r\n\r\n/**\r\n * A value or a function returning a value. Used for reactive or static props.\r\n * @example\r\n * type X = MaybeFunction<string>; // string | () => string\r\n */\r\nexport type MaybeFunction<T> = T | (() => T);\r\n\r\n/**\r\n * Props where each value can be a value or a function, except for event handlers and refs.\r\n * @example\r\n * type P = MaybeFunctionProps<{ foo: number; onClick: () => void }>\r\n */\r\nexport type MaybeFunctionProps<T extends Record<string, any>> = {\r\n  [K in keyof T]: K extends `on${string}` | \"ref\" ? T[K] : MaybeFunction<T[K]>;\r\n};\r\n\r\nexport function H(rules: AssignmentRules = []) {\r\n  function h<T extends ValidComponent>(\r\n    component: T,\r\n    props: MaybeFunctionProps<ComponentProps<T>>,\r\n    ...children: JSX.Element[]\r\n  ): JSX.Element {\r\n    //children in spread syntax override children in props\r\n    if (children.length === 1) {\r\n      //@ts-expect-error\r\n      props.children = children[0];\r\n    } else if (children.length > 1) {\r\n      //@ts-expect-error\r\n      props.children = children;\r\n    }\r\n\r\n    if (isString(component)) {\r\n      const elem = doc.createElement(component);\r\n      spread(rules, elem, wrapProps(props));\r\n      return elem;\r\n    } else if (isFunction(component)) {\r\n      return createComponent(component, wrapProps(props));\r\n    }\r\n  }\r\n\r\n  h.addRules = (...newRules: AssignmentRules) => {\r\n    rules.push(...newRules);\r\n  };\r\n\r\n  return h;\r\n}\r\n\r\nexport const h = H(defaultRules);\r\n\r\nexport const markedOnce = new WeakSet();\r\n\r\n/**\r\n * Marks a function so it is not wrapped as a getter by h().\r\n * Useful for event handlers or functions that should not be auto-accessed.\r\n * @example\r\n * once(() => doSomething())\r\n */\r\nexport function once<T extends (...args: any[]) => any>(fn: T): T {\r\n  markedOnce.add(fn);\r\n  return fn;\r\n}\r\n\r\n/**\r\n * Internal: Replaces accessor props with getters for reactivity, except for refs and event handlers.\r\n */\r\nfunction wrapProps<\r\n  TComponent extends ValidComponent,\r\n  TProps extends MaybeFunctionProps<ComponentProps<TComponent>>\r\n>(props: TProps = {} as TProps): ComponentProps<TComponent> {\r\n  for (const [key, descriptor] of Object.entries(\r\n    Object.getOwnPropertyDescriptors(props)\r\n  )) {\r\n    const value = descriptor.value;\r\n    if (isFunction(value) && value.length === 0 && !markedOnce.has(value)) {\r\n      Object.defineProperty(props, key, {\r\n        get() {\r\n          return value();\r\n        },\r\n        enumerable: true,\r\n      });\r\n    }\r\n  }\r\n  return props as ComponentProps<TComponent>;\r\n}\r\n","import {\r\n  type Context as _Context,\r\n  ErrorBoundary as _ErrorBoundary,\r\n  For as _For,\r\n  Index as _Index,\r\n  Match as _Match,\r\n  Show as _Show,\r\n  Suspense as _Suspense,\r\n  Switch as _Switch,\r\n  type JSX,\r\n} from \"solid-js\";\r\nimport { MaybeFunction, h, once } from \"./h\";\r\n\r\n/**\r\n * Solid-compatible Show component. Renders children if `when` is truthy, otherwise renders `fallback`.\r\n * @example\r\n * Show(() => isVisible(), html`<span>Hello</span>`, \"Fallback\")\r\n */\r\nexport function Show(\r\n  when: () => boolean,\r\n  children: MaybeFunction<JSX.Element>,\r\n  fallback?: MaybeFunction<JSX.Element>\r\n): JSX.Element {\r\n  return h(_Show, {\r\n    when,\r\n    children,\r\n    fallback,\r\n    //@ts-expect-error\r\n    keyed: false,\r\n  });\r\n}\r\n\r\n/**\r\n * Show component with keyed mode. Renders children with keyed context if `when` is truthy.\r\n * @example\r\n * ShowKeyed(() => user(), user => html`<span>${user.name}</span>`, \"No user\")\r\n */\r\nexport function ShowKeyed<T>(\r\n  when: () => T,\r\n  children: JSX.Element | ((item: NonNullable<T>) => JSX.Element),\r\n  fallback?: MaybeFunction<JSX.Element>\r\n): JSX.Element {\r\n  return h(_Show, {\r\n    when,\r\n    //@ts-expect-error\r\n    children,\r\n    fallback,\r\n    keyed: true,\r\n  });\r\n}\r\n\r\n/**\r\n * Switch component for conditional rendering. Renders the first matching child, or `fallback` if none match.\r\n * @example\r\n * Switch(\"No match\", Match(() => cond1(), html`A`), Match(() => cond2(), html`B`))\r\n */\r\nexport function Switch(\r\n  fallback: MaybeFunction<JSX.Element>,\r\n  ...children: JSX.Element[]\r\n): JSX.Element {\r\n  return h(_Switch, { children, fallback });\r\n}\r\n\r\n/**\r\n * Match component for use inside Switch. Renders children if `when` is truthy.\r\n * @example\r\n * Match(() => value() === 1, html`One`)\r\n */\r\nexport function Match<T>(\r\n  when: () => T | undefined | null | false,\r\n  children: JSX.Element | ((item: T) => JSX.Element)\r\n): JSX.Element {\r\n  //@ts-expect-error\r\n  return h(_Match, { when, children, keyed: false });\r\n}\r\n\r\n/**\r\n * Keyed Match component for use inside Switch. Renders children with keyed context if `when` is truthy.\r\n * @example\r\n * MatchKeyed(() => user(), user => html`<span>${user.name}</span>`)\r\n */\r\nexport function MatchKeyed<T>(\r\n  when: () => T | undefined | null | false,\r\n  children: JSX.Element | ((item: T) => JSX.Element)\r\n): JSX.Element {\r\n  // @ts-expect-error\r\n  return h(_Match, { when, children, keyed: true });\r\n}\r\n\r\n/**\r\n * For component for iterating over arrays. Renders children for each item in `each`.\r\n * @example\r\n * For(() => items(), (item) => html`<li>${item}</li>`)\r\n */\r\nexport function For<T extends readonly any[]>(\r\n  each: () => T | false | null | undefined,\r\n  children: (item: T[number], index: () => number) => JSX.Element,\r\n  fallback?: MaybeFunction<JSX.Element>\r\n): JSX.Element {\r\n  return h(_For, {\r\n    get each() {\r\n      return each();\r\n    },\r\n    children: once(children),\r\n    fallback,\r\n  });\r\n}\r\n\r\n/**\r\n * Index component for iterating over arrays by index. Renders children for each item in `each`.\r\n * @example\r\n * Index(() => items(), (item, i) => html`<li>${item()}</li>`)\r\n */\r\nexport function Index<T extends readonly any[]>(\r\n  each: () => T | false | null | undefined,\r\n  children: (item: () => T[number], index: number) => JSX.Element,\r\n  fallback?: MaybeFunction<JSX.Element>\r\n): JSX.Element {\r\n  return h(_Index, {\r\n    get each() {\r\n      return each();\r\n    },\r\n    children: once(children),\r\n    fallback,\r\n  });\r\n}\r\n\r\n/**\r\n * Suspense component for async boundaries. Renders `children` or `fallback` while loading.\r\n * @example\r\n * Suspense(html`<div>Loaded</div>`, html`<div>Loading...</div>`)\r\n */\r\nexport function Suspense(\r\n  children: MaybeFunction<JSX.Element>,\r\n  fallback?: MaybeFunction<JSX.Element>\r\n): JSX.Element {\r\n  return h(_Suspense, { children, fallback });\r\n}\r\n\r\n/**\r\n * ErrorBoundary component. Catches errors in children and renders `fallback` on error.\r\n * @example\r\n * ErrorBoundary(html`<App />`, (err) => html`<div>Error: ${err.message}</div>`)\r\n */\r\nexport function ErrorBoundary(\r\n  children: MaybeFunction<JSX.Element>,\r\n  fallback:\r\n    | MaybeFunction<JSX.Element>\r\n    | ((err: any, reset: () => void) => JSX.Element)\r\n): JSX.Element {\r\n  return h(_ErrorBoundary, { children, fallback });\r\n}\r\n\r\n/**\r\n * Context provider component. Provides a context value to all children.\r\n * @example\r\n * Context(MyContext, value, () => html`<Child />`)\r\n */\r\nexport function Context<T>(\r\n  context: _Context<T>,\r\n  value: T | (() => T),\r\n  children: () => JSX.Element\r\n): JSX.Element {\r\n  return h(context.Provider, { value, children });\r\n}\r\n","// Added to an attribute name to mark the attribute as bound so we can find\r\n// it easily.\r\nexport const boundAttributeSuffix = \"$lit$\";\r\n\r\n// This marker is used in many syntactic positions in HTML, so it must be\r\n// a valid element name and attribute name. We don't support dynamic names (yet)\r\n// but this at least ensures that the parse tree is closer to the template\r\n// intention.\r\nexport const marker = `lit$marker$`;\r\n\r\n// String used to tell if a comment is a marker comment\r\nexport const markerMatch = \"?\" + marker;\r\n\r\n// Text used to insert a comment marker node. We use processing instruction\r\n// syntax because it's slightly smaller, but parses as a comment node.\r\nexport const nodeMarker = `<${markerMatch}>`;\r\n\r\n\r\nconst SPACE_CHAR = `[ \\t\\n\\f\\r]`;\r\nconst ATTR_VALUE_CHAR = `[^ \\t\\n\\f\\r\"'\\`<>=]`;\r\nconst NAME_CHAR = `[^\\\\s\"'>=/]`;\r\n\r\n// These regexes represent the five parsing states that we care about in the\r\n// Template's HTML scanner. They match the *end* of the state they're named\r\n// after.\r\n// Depending on the match, we transition to a new state. If there's no match,\r\n// we stay in the same state.\r\n// Note that the regexes are stateful. We utilize lastIndex and sync it\r\n// across the multiple regexes used. In addition to the five regexes below\r\n// we also dynamically create a regex to find the matching end tags for raw\r\n// text elements.\r\n\r\n/**\r\n * End of text is: `<` followed by:\r\n *   (comment start) or (tag) or (dynamic tag binding)\r\n */\r\nconst textEndRegex = /<(?:(!--|\\/[^a-zA-Z])|(\\/?[a-zA-Z][^>\\s]*)|(\\/?$))/g;\r\nconst COMMENT_START = 1;\r\nconst TAG_NAME = 2;\r\nconst DYNAMIC_TAG_NAME = 3;\r\n\r\nconst commentEndRegex = /-->/g;\r\n/**\r\n * Comments not started with <!--, like </{, can be ended by a single `>`\r\n */\r\nconst comment2EndRegex = />/g;\r\n\r\n/**\r\n * The tagEnd regex matches the end of the \"inside an opening\" tag syntax\r\n * position. It either matches a `>`, an attribute-like sequence, or the end\r\n * of the string after a space (attribute-name position ending).\r\n *\r\n * See attributes in the HTML spec:\r\n * https://www.w3.org/TR/html5/syntax.html#elements-attributes\r\n *\r\n * \" \\t\\n\\f\\r\" are HTML space characters:\r\n * https://infra.spec.whatwg.org/#ascii-whitespace\r\n *\r\n * So an attribute is:\r\n *  * The name: any character except a whitespace character, (\"), ('), \">\",\r\n *    \"=\", or \"/\". Note: this is different from the HTML spec which also excludes control characters.\r\n *  * Followed by zero or more space characters\r\n *  * Followed by \"=\"\r\n *  * Followed by zero or more space characters\r\n *  * Followed by:\r\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\r\n *    * (\") then any non-(\"), or\r\n *    * (') then any non-(')\r\n */\r\nconst tagEndRegex = new RegExp(\r\n  `>|${SPACE_CHAR}(?:(${NAME_CHAR}+)(${SPACE_CHAR}*=${SPACE_CHAR}*(?:${ATTR_VALUE_CHAR}|(\"|')|))|$)`,\r\n  \"g\"\r\n);\r\nconst ENTIRE_MATCH = 0;\r\nconst ATTRIBUTE_NAME = 1;\r\nconst SPACES_AND_EQUALS = 2;\r\nconst QUOTE_CHAR = 3;\r\n\r\nconst singleQuoteAttrEndRegex = /'/g;\r\nconst doubleQuoteAttrEndRegex = /\"/g;\r\n/**\r\n * Matches the raw text elements.\r\n *\r\n * Comments are not parsed within raw text elements, so we need to search their\r\n * text content for marker strings.\r\n */\r\nconst rawTextElement = /^(?:script|style|textarea|title)$/i;\r\n\r\n/** TemplateResult types */\r\nexport const HTML_RESULT = 1;\r\nexport const SVG_RESULT = 2;\r\nexport const MATHML_RESULT = 3;\r\n\r\nexport type ResultType = typeof HTML_RESULT | typeof SVG_RESULT | typeof MATHML_RESULT;\r\n\r\n\r\n\r\n/**\r\n * Returns an HTML string for the given TemplateStringsArray and result type\r\n * (HTML or SVG), along with the case-sensitive bound attribute names in\r\n * template order. The HTML contains comment markers denoting the `ChildPart`s\r\n * and suffixes on bound attributes denoting the `AttributeParts`.\r\n *\r\n * @param strings template strings array\r\n * @param type HTML or SVG\r\n * @return Array containing `[html, attrNames]` (array returned for terseness,\r\n *     to avoid object fields since this code is shared with non-minified SSR\r\n *     code)\r\n */\r\nexport const getTemplateHtml = (\r\n  strings: TemplateStringsArray,\r\n  type: ResultType\r\n): [string, Array<string>] => {\r\n  // Insert makers into the template HTML to represent the position of\r\n  // bindings. The following code scans the template strings to determine the\r\n  // syntactic position of the bindings. They can be in text position, where\r\n  // we insert an HTML comment, attribute value position, where we insert a\r\n  // sentinel string and re-write the attribute name, or inside a tag where\r\n  // we insert the sentinel string.\r\n  const l = strings.length - 1;\r\n  // Stores the case-sensitive bound attribute names in the order of their\r\n  // parts. ElementParts are also reflected in this array as undefined\r\n  // rather than a string, to disambiguate from attribute bindings.\r\n  const attrNames: Array<string> = [];\r\n  let html =\r\n    type === SVG_RESULT ? \"<svg>\" : type === MATHML_RESULT ? \"<math>\" : \"\";\r\n\r\n  // When we're inside a raw text tag (not it's text content), the regex\r\n  // will still be tagRegex so we can find attributes, but will switch to\r\n  // this regex when the tag ends.\r\n  let rawTextEndRegex: RegExp | undefined;\r\n\r\n  // The current parsing state, represented as a reference to one of the\r\n  // regexes\r\n  let regex = textEndRegex;\r\n\r\n  for (let i = 0; i < l; i++) {\r\n    const s = strings[i];\r\n    // The index of the end of the last attribute name. When this is\r\n    // positive at end of a string, it means we're in an attribute value\r\n    // position and need to rewrite the attribute name.\r\n    // We also use a special value of -2 to indicate that we encountered\r\n    // the end of a string in attribute name position.\r\n    let attrNameEndIndex = -1;\r\n    let attrName: string | undefined;\r\n    let lastIndex = 0;\r\n    let match!: RegExpExecArray | null;\r\n\r\n    // The conditions in this loop handle the current parse state, and the\r\n    // assignments to the `regex` variable are the state transitions.\r\n    while (lastIndex < s.length) {\r\n      // Make sure we start searching from where we previously left off\r\n      regex.lastIndex = lastIndex;\r\n      match = regex.exec(s);\r\n      if (match === null) {\r\n        break;\r\n      }\r\n      lastIndex = regex.lastIndex;\r\n      if (regex === textEndRegex) {\r\n        if (match[COMMENT_START] === \"!--\") {\r\n          regex = commentEndRegex;\r\n        } else if (match[COMMENT_START] !== undefined) {\r\n          // We started a weird comment, like </{\r\n          regex = comment2EndRegex;\r\n        } else if (match[TAG_NAME] !== undefined) {\r\n          if (rawTextElement.test(match[TAG_NAME])) {\r\n            // Record if we encounter a raw-text element. We'll switch to\r\n            // this regex at the end of the tag.\r\n            rawTextEndRegex = new RegExp(`</${match[TAG_NAME]}`, \"g\");\r\n          }\r\n          regex = tagEndRegex;\r\n        } else if (match[DYNAMIC_TAG_NAME] !== undefined) {\r\n          regex = tagEndRegex;\r\n        }\r\n      } else if (regex === tagEndRegex) {\r\n        if (match[ENTIRE_MATCH] === \">\") {\r\n          // End of a tag. If we had started a raw-text element, use that\r\n          // regex\r\n          regex = rawTextEndRegex ?? textEndRegex;\r\n          // We may be ending an unquoted attribute value, so make sure we\r\n          // clear any pending attrNameEndIndex\r\n          attrNameEndIndex = -1;\r\n        } else if (match[ATTRIBUTE_NAME] === undefined) {\r\n          // Attribute name position\r\n          attrNameEndIndex = -2;\r\n        } else {\r\n          attrNameEndIndex = regex.lastIndex - match[SPACES_AND_EQUALS].length;\r\n          attrName = match[ATTRIBUTE_NAME];\r\n          regex =\r\n            match[QUOTE_CHAR] === undefined\r\n              ? tagEndRegex\r\n              : match[QUOTE_CHAR] === '\"'\r\n              ? doubleQuoteAttrEndRegex\r\n              : singleQuoteAttrEndRegex;\r\n        }\r\n      } else if (\r\n        regex === doubleQuoteAttrEndRegex ||\r\n        regex === singleQuoteAttrEndRegex\r\n      ) {\r\n        regex = tagEndRegex;\r\n      } else if (regex === commentEndRegex || regex === comment2EndRegex) {\r\n        regex = textEndRegex;\r\n      } else {\r\n        // Not one of the five state regexes, so it must be the dynamically\r\n        // created raw text regex and we're at the close of that element.\r\n        regex = tagEndRegex;\r\n        rawTextEndRegex = undefined;\r\n      }\r\n    }\r\n\r\n    // We have four cases:\r\n    //  1. We're in text position, and not in a raw text element\r\n    //     (regex === textEndRegex): insert a comment marker.\r\n    //  2. We have a non-negative attrNameEndIndex which means we need to\r\n    //     rewrite the attribute name to add a bound attribute suffix.\r\n    //  3. We're at the non-first binding in a multi-binding attribute, use a\r\n    //     plain marker.\r\n    //  4. We're somewhere else inside the tag. If we're in attribute name\r\n    //     position (attrNameEndIndex === -2), add a sequential suffix to\r\n    //     generate a unique attribute name.\r\n\r\n    // Detect a binding next to self-closing tag end and insert a space to\r\n    // separate the marker from the tag end:\r\n    const end =\r\n      regex === tagEndRegex && strings[i + 1].startsWith(\"/>\") ? \" \" : \"\";\r\n    html +=\r\n      regex === textEndRegex\r\n        ? s + nodeMarker\r\n        : attrNameEndIndex >= 0\r\n        ? (attrNames.push(attrName!),\r\n          s.slice(0, attrNameEndIndex) +\r\n            boundAttributeSuffix +\r\n            s.slice(attrNameEndIndex)) +\r\n          marker +\r\n          end\r\n        : s + marker + (attrNameEndIndex === -2 ? i : end);\r\n  }\r\n\r\n  const htmlResult: string =\r\n    html +\r\n    (strings[l] || \"<?>\") +\r\n    (type === SVG_RESULT ? \"</svg>\" : type === MATHML_RESULT ? \"</math>\" : \"\");\r\n\r\n  // Returned as an array for terseness\r\n  return [htmlResult, attrNames];\r\n};\r\n","import { type JSX } from \"solid-js\";\r\nimport {\r\n  DelegatedEvents,\r\n  SVGElements,\r\n  addEventListener,\r\n  delegateEvents,\r\n  effect,\r\n  insert,\r\n  setAttribute,\r\n  setBoolAttribute,\r\n  setProperty,\r\n  style,\r\n} from \"solid-js/web\";\r\nimport {\r\n  HTML_RESULT,\r\n  MATHML_RESULT,\r\n  ResultType,\r\n  boundAttributeSuffix,\r\n  getTemplateHtml,\r\n  marker,\r\n  markerMatch,\r\n  SVG_RESULT,\r\n} from \"./lit-html\";\r\nimport { doc, isFunction } from \"./util\";\r\nimport { markedOnce } from \"./h\";\r\nimport { assign, AssignmentFunction, AssignmentRules, defaultRules, spread } from \"./assign\";\r\n\r\n\r\n\r\ntype Template = [element: HTMLTemplateElement, attributes: string[]];\r\n\r\nconst walker = doc.createTreeWalker(doc, 129);\r\n\r\nconst templateCache = new WeakMap<TemplateStringsArray, Template>();\r\n\r\n/**\r\n * Returns a parsed template and its bound attributes for a given template string and type.\r\n * @internal\r\n */\r\nfunction getTemplate(\r\n  strings: TemplateStringsArray,\r\n  type: ResultType\r\n): Template {\r\n  let template = templateCache.get(strings);\r\n  if (template === undefined) {\r\n    const [html, attributes] = getTemplateHtml(strings, type);\r\n    const element = doc.createElement(\"template\");\r\n    element.innerHTML = html;\r\n    template = [element, attributes];\r\n    templateCache.set(strings, template);\r\n  }\r\n  return template;\r\n}\r\n\r\n\r\n\r\n/**\r\n * Creates a tagged template function for html/svg/mathml templates with Solid reactivity.\r\n * @internal\r\n */\r\nexport function HTML(rules: AssignmentRules = [],type: ResultType = 1) {\r\n  return function html(\r\n    strings: TemplateStringsArray,\r\n    ...values: any[]\r\n  ): JSX.Element {\r\n    function render() {\r\n      const [element, attributes] = getTemplate(strings, type);\r\n      const clone = element.content.cloneNode(true);\r\n\r\n      let valueIndex = 0;\r\n      let boundAttributeIndex = 0;\r\n      walker.currentNode = clone;\r\n\r\n      while (walker.nextNode()) {\r\n        const node = walker.currentNode;\r\n        if (node.nodeType === 1) {\r\n          for (const attr of [...(node as Element).attributes]) {\r\n            if (attr.name.endsWith(boundAttributeSuffix)) {\r\n              //Bound attribute/prop/event\r\n              let value: any\r\n              if (attr.value === marker) {\r\n                value = values[valueIndex++];\r\n              } else {\r\n                const strings = attr.value.split(marker);\r\n                let parts = [strings[0]] as any[];\r\n                for (let j = 1; j < strings.length; j++) {\r\n                  parts.push(values[valueIndex++], strings[j]);\r\n                }\r\n                value = () => parts.map((v) => (isFunction(v) ? v() : v)).join(\"\");\r\n\r\n              }\r\n              assign(rules, node as Element, attributes[boundAttributeIndex++], value);\r\n              (node as Element).removeAttribute(attr.name);\r\n            } else if (attr.name === `...${marker}`) {\r\n              //Spread\r\n              const isSvg = SVGElements.has((node as Element).tagName);\r\n              const value = values[valueIndex++];\r\n              if (isFunction(value)) {\r\n                effect(() => spread(rules,node as Element, value() ));\r\n              } else {\r\n                spread(rules, node as Element, value);\r\n              }\r\n              (node as Element).removeAttribute(attr.name);\r\n            } else if (attr.name.startsWith(marker)) {\r\n              //Refs\r\n              const value = values[valueIndex++];\r\n              if (isFunction(value)) {\r\n                value(node as Element);\r\n              }\r\n              (node as Element).removeAttribute(attr.name);\r\n            }\r\n          }\r\n        } else if (node.nodeType === 8) {\r\n          if (node.nodeValue === markerMatch) {\r\n            node.nodeValue = marker + valueIndex; //I don't know why, but this prevents misplaced elements\r\n            const value = values[valueIndex++];\r\n            const parent = node.parentNode;\r\n            if (parent) insert(parent, value, node);\r\n          }\r\n        }\r\n      }\r\n      if (type === SVG_RESULT || type === MATHML_RESULT) {\r\n        return [...clone.firstChild!.childNodes];\r\n      }\r\n      return [...clone.childNodes];\r\n    }\r\n\r\n    render.addRules = (...newRules: AssignmentRules) => {\r\n      rules.push(...newRules);\r\n    }\r\n\r\n\r\n    return render as unknown as JSX.Element;\r\n  };\r\n}\r\n\r\n/**\r\n * Tagged template for creating reactive HTML templates with Solid. Use for DOM elements only.\r\n *\r\n * @example\r\n * html`<div class=\"foo\">${bar}</div>`\r\n * html`<button @click=${onClick}>Click</button>`\r\n */\r\nexport const html = HTML(defaultRules, HTML_RESULT);\r\n\r\n/**\r\n * Tagged template for creating reactive SVG templates with Solid. Use inside <svg> only.\r\n *\r\n * @example\r\n * svg`<circle cx=\"10\" cy=\"10\" r=\"5\" />`\r\n */\r\nexport const svg = HTML(defaultRules, SVG_RESULT);\r\n\r\n/**\r\n * Tagged template for creating reactive MathML templates with Solid. Use inside <math> only.\r\n *\r\n * @example\r\n * mathml`<math><mi>x</mi></math>`\r\n */\r\nexport const mathml = HTML(defaultRules, MATHML_RESULT);\r\n","import {\r\n  ErrorBoundary,\r\n  For,\r\n  Index,\r\n  Match,\r\n  Show,\r\n  Suspense,\r\n  Switch,\r\n} from \"solid-js\";\r\nimport { H } from \"./h\";\r\nimport { Dynamic, NoHydration, Portal } from \"solid-js/web\";\r\nimport { doc, isFunction } from \"./util\";\r\nimport { AssignmentRules, defaultRules } from \"./assign\";\r\n\r\n/**\r\n * Default registry of built-in Solid control flow and utility components for XML templates.\r\n */\r\nconst defaultRegistry = {\r\n  For,\r\n  Index,\r\n  Match,\r\n  Suspense,\r\n  ErrorBoundary,\r\n  Show,\r\n  Switch,\r\n  Dynamic,\r\n  Portal,\r\n  NoHydration,\r\n};\r\n\r\nconst xmlns = [\"on\", \"prop\", \"bool\", \"attr\"]\r\n  .map((ns) => `xmlns:${ns}=\"/\"`)\r\n  .join(\" \");\r\n\r\nconst marker = \"MARKER46846\";\r\nconst markerRX = new RegExp(`(${marker})`, \"g\");\r\nconst markerAttr = new RegExp(`=${marker}`, \"g\");\r\n\r\nconst xmlCache = new WeakMap<TemplateStringsArray, Node>();\r\n\r\n/**\r\n * Parses a template string as XML and returns the child nodes, using a cache for performance.\r\n * @internal\r\n */\r\nfunction getXml(strings: TemplateStringsArray) {\r\n  let xml = xmlCache.get(strings);\r\n  if (xml === undefined) {\r\n    const contents = strings.join(marker).replace(markerAttr, `=\"${marker}\"`);\r\n    const parser = new DOMParser();\r\n    xml = parser.parseFromString(`<xml ${xmlns}>${contents}</xml>`, \"text/xml\")\r\n      .firstChild!;\r\n    xmlCache.set(strings, xml);\r\n  }\r\n  return xml.childNodes;\r\n}\r\n\r\nconst flat = (arr: any) => (arr.length === 1 ? arr[0] : arr);\r\nfunction getValue(value: any) {\r\n  while (isFunction(value)) value = value();\r\n  return value;\r\n}\r\nconst toArray = Array.from;\r\n\r\n/**\r\n * Converts parsed XML nodes and values into Solid hyperscript calls.\r\n * @internal\r\n */\r\nfunction toH(\r\n  jsx: ReturnType<typeof XML>,\r\n  cached: NodeList,\r\n  values: any[],\r\n  rules: AssignmentRules\r\n) {\r\n  let index = 0;\r\n  const h = H(rules);\r\n  function nodes(node: any) {\r\n    // console.log(node)\r\n    if (node.nodeType === 1) {\r\n      // element\r\n      const tagName = node.tagName;\r\n\r\n      // gather props\r\n      const props = {} as Record<string, any>;\r\n      for (let { name, value } of node.attributes) {\r\n        if (value === marker) {\r\n          value = values[index++];\r\n        } else if (value.includes(marker)) {\r\n          const val = value\r\n            .split(markerRX)\r\n            .map((x: string) => (x === marker ? values[index++] : x));\r\n\r\n          value = () => val.map(getValue).join(\"\");\r\n        }\r\n        props[name] = value;\r\n      }\r\n\r\n      // gather children\r\n      const childNodes = node.childNodes;\r\n      if (childNodes.length) {\r\n        props.children = flat(\r\n          toArray(childNodes)\r\n            .map(nodes)\r\n            .filter((n) => n)\r\n        );\r\n      }\r\n\r\n      /[A-Z]/.test(tagName) &&\r\n        !jsx.components[tagName] &&\r\n        console.warn(`xml: Forgot to jsx.define({ ${tagName} })?`);\r\n\r\n      return () => h(jsx.components[tagName] || tagName, props);\r\n    } else if (node.nodeType === 3) {\r\n      // text\r\n\r\n      const value = node.nodeValue;\r\n      if (value.trim() === marker) {\r\n        return values[index++];\r\n      }\r\n      return value.includes(marker)\r\n        ? value\r\n            .split(markerRX)\r\n            .map((x: string) => (x === marker ? values[index++] : x))\r\n        : value;\r\n    } else if (node.nodeType === 8) {\r\n      // comment\r\n      const value = node.nodeValue;\r\n      if (value.includes(marker)) {\r\n        const val = value\r\n          .split(markerRX)\r\n          .map((x: string) => (x === marker ? values[index++] : x));\r\n        return () => doc.createComment(val.map(getValue).join(\"\"));\r\n      } else {\r\n        return doc.createComment(value);\r\n      }\r\n    } else {\r\n      console.error(`xml: nodeType not supported ${node.nodeType}`);\r\n    }\r\n  }\r\n\r\n  return flat(toArray(cached).map(nodes));\r\n}\r\n\r\n/**\r\n * Creates an XML template tag function for Solid, supporting custom component registries.\r\n * Use `xml.define({ ... })` to add or override components.\r\n *\r\n * @example\r\n * const xml = XML({ MyComponent })\r\n * xml`<MyComponent foo=\"bar\">${child}</MyComponent>`\r\n *\r\n * @param userComponents Custom components to add to the registry.\r\n * @returns An xml template tag function.\r\n */\r\nexport function XML(\r\n  rules: AssignmentRules = defaultRules,\r\n  components: Record<string, any> = {}\r\n) {\r\n  function xml(template: TemplateStringsArray, ...values: any[]) {\r\n    return toH(xml, getXml(template), values, rules);\r\n  }\r\n\r\n  xml.components = { ...defaultRegistry, ...components };\r\n  xml.define = (userComponents: Record<string, any>) => {\r\n    Object.assign(xml.components, userComponents);\r\n  };\r\n  xml.addRules = (...newRules: AssignmentRules) => {\r\n    rules.push(...newRules);\r\n  };\r\n\r\n  return xml;\r\n}\r\n\r\n/**\r\n * Default XML template tag for Solid, with built-in registry. Use `xml.define` to add components.\r\n *\r\n * @example\r\n * xml`<For each=${list}>${item => xml`<div>${item}</div>`}</For>`\r\n */\r\nexport const xml = XML(defaultRules);\r\n"],"mappings":"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"}