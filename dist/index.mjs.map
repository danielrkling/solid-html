{"version":3,"file":"index.mjs","names":["value: MaybeFunction<T>","when: () => T","children: (item: Accessor<NonNullable<T>>)=>JSX.Element","fallback?: ()=>JSX.Element","_Show","children: ((item: NonNullable<T>) => JSX.Element)","children: ()=>JSX.Element[]","fallback: ()=>JSX.Element","_Switch","children: ((item: Accessor<NonNullable<T>>) => JSX.Element)","_Match","each: () => T | false | null | undefined","children: (item: T[number], index: () => number) => JSX.Element","_For","children: (item: () => T[number], index: number) => JSX.Element","_Index","children: ()=>JSX.Element","_Suspense","fallback: ((err: any, reset: () => void) => JSX.Element)","_ErrorBoundary","context: _Context<T>","value: T","children: () => JSX.Element","value: any","node: Element","name: string","value: any","prev?: any","namespace: string","rules: AssignmentRule[]","elem: Element","assign","props: any","prev: any","strings: TemplateStringsArray","type: ResultType","attrNames: Array<string>","html","rawTextEndRegex: RegExp | undefined","attrName: string | undefined","match!: RegExpExecArray | null","match","end","htmlResult: string","strings: TemplateStringsArray","type: ResultType","html","rules: AssignmentRule[]","value: any","strings","strings: TemplateStringsArray","xmlns: string[]","xml","arr: any","getValue","value: any","values: any[]","value: string | null","components: ComponentRegistry","rules: AssignmentRule[]","template: TemplateStringsArray","node: Node","defaultRules: AssignmentRule[]","defaultComponents: ComponentRegistry","components: Record<string, any>","rules: AssignmentRule[]","h","component: T","props: MaybeFunctionProps<ComponentProps<T>>","components: Record<string, ValidComponent>","components","fn: T","props: TProps"],"sources":["../src/components.ts","../src/util.ts","../src/assign.ts","../src/lit-html.ts","../src/html.ts","../src/xml.ts","../src/defaults.ts","../src/h.ts"],"sourcesContent":["import {\n  type Context as _Context,\n  ErrorBoundary as _ErrorBoundary,\n  For as _For,\n  Index as _Index,\n  Match as _Match,\n  Show as _Show,\n  Suspense as _Suspense,\n  Switch as _Switch,\n  createComponent,\n  JSX,\n  Accessor,\n} from \"solid-js\";\nimport { MaybeFunction } from \"./types\";\n\nexport function getValue<T>(value: MaybeFunction<T>): T {\n  if (typeof value === \"function\") {\n    //@ts-expect-error\n    return value();\n  }else{\n    return value;\n  }\n}\n\n/**\n * Solid-compatible Show component. Renders children if `when` is truthy, otherwise renders `fallback`.\n * @example\n * Show(() => isVisible(), html`<span>Hello</span>`, \"Fallback\")\n */\nexport function Show<T>(\n  when: () => T,\n  children: (item: Accessor<NonNullable<T>>)=>JSX.Element,\n  fallback?: ()=>JSX.Element\n): JSX.Element {\n  return createComponent(_Show, {\n    get when() {\n      return when();\n    },\n    //@ts-expect-error\n    children,\n    get fallback(){\n      return fallback?.()\n    },\n    //@ts-expect-error\n    keyed: false,\n  });\n}\n\n\n\n/**\n * Show component with keyed mode. Renders children with keyed context if `when` is truthy.\n * @example\n * ShowKeyed(() => user(), user => html`<span>${user.name}</span>`, \"No user\")\n */\nexport function ShowKeyed<T>(\n  when: () => T,\n  children: ((item: NonNullable<T>) => JSX.Element),\n  fallback?: ()=>JSX.Element\n): JSX.Element {\n  return createComponent(_Show, {\n    get when() {\n      return when();\n    },\n    //@ts-expect-error\n    children,\n    get fallback(){\n      return fallback?.()\n    },\n    keyed: true,\n  });\n}\n\n/**\n * Switch component for conditional rendering. Renders the first matching child, or `fallback` if none match.\n * @example\n * Switch(\"No match\", Match(() => cond1(), html`A`), Match(() => cond2(), html`B`))\n */\nexport function Switch(\n  children: ()=>JSX.Element[],\n  fallback: ()=>JSX.Element,  \n): JSX.Element {\n  return createComponent(_Switch, {\n    get fallback() {\n      return fallback();\n    },\n    get children(){\n      return children()\n    }\n  });\n}\n\n/**\n * Match component for use inside Switch. Renders children if `when` is truthy.\n * @example\n * Match(() => value() === 1, html`One`)\n */\nexport function Match<T>(\n  when: () => T,\n  children: ((item: Accessor<NonNullable<T>>) => JSX.Element)\n): JSX.Element {\n  return createComponent(_Match, {\n    get when() {\n      return when();\n    },\n    //@ts-expect-error\n    children,\n  });\n}\n\n/**\n * Keyed Match component for use inside Switch. Renders children with keyed context if `when` is truthy.\n * @example\n * MatchKeyed(() => user(), user => html`<span>${user.name}</span>`)\n */\nexport function MatchKeyed<T>(\n  when: () => T,\n  children: ((item: NonNullable<T>) => JSX.Element)\n): JSX.Element {\n  return createComponent(_Match, {\n    get when() {\n      return when();\n    },\n    //@ts-expect-error\n    children,\n    keyed: true\n  });\n}\n\n/**\n * For component for iterating over arrays. Renders children for each item in `each`.\n * @example\n * For(() => items(), (item) => html`<li>${item}</li>`)\n */\nexport function For<T extends readonly any[]>(\n  each: () => T | false | null | undefined,\n  children: (item: T[number], index: () => number) => JSX.Element,\n  fallback?: ()=>JSX.Element\n): JSX.Element {\n  return createComponent(_For, {\n    get each() {\n      return each();\n    },\n    children,\n    get fallback() {\n      return fallback?.();\n    }\n  });\n}\n\n/**\n * Index component for iterating over arrays by index. Renders children for each item in `each`.\n * @example\n * Index(() => items(), (item, i) => html`<li>${item()}</li>`)\n */\nexport function Index<T extends readonly any[]>(\n  each: () => T | false | null | undefined,\n  children: (item: () => T[number], index: number) => JSX.Element,\n  fallback?: ()=>JSX.Element\n): JSX.Element {\n  return createComponent(_Index, {\n    get each() {\n      return each();\n    },\n    children,\n    get fallback() {\n      return fallback?.()\n    }\n  });\n}\n\n/**\n * Suspense component for async boundaries. Renders `children` or `fallback` while loading.\n * @example\n * Suspense(html`<div>Loaded</div>`, html`<div>Loading...</div>`)\n */\nexport function Suspense(\n  children: ()=>JSX.Element,\n  fallback?: ()=>JSX.Element\n): JSX.Element {\n  return createComponent(_Suspense, {\n    get children() {\n      return children()\n    },\n    get fallback() {\n      return fallback?.()\n    },\n  });\n}\n\n/**\n * ErrorBoundary component. Catches errors in children and renders `fallback` on error.\n * @example\n * ErrorBoundary(html`<App />`, (err) => html`<div>Error: ${err.message}</div>`)\n */\nexport function ErrorBoundary(\n  children: ()=>JSX.Element,\n  fallback: ((err: any, reset: () => void) => JSX.Element)\n): JSX.Element {\n  return createComponent(_ErrorBoundary, {\n    get children() {\n      return children()\n    },\n    fallback\n  });\n}\n\n/**\n * Context provider component. Provides a context value to all children.\n * @example\n * Context(MyContext, value, () => html`<Child />`)\n */\nexport function Context<T>(\n  context: _Context<T>,\n  value: T,\n  children: () => JSX.Element\n): JSX.Element {\n  return createComponent(context.Provider, {\n    get children() {\n      return children()\n    },\n    value\n  });\n}\n","import { MaybeFunction } from \"./types\";\n\nexport function isString(value: any): value is string {\n  return typeof value === \"string\";\n}\n\nexport function isFunction(value: any): value is Function {\n  return typeof value === \"function\";\n}\n\nexport function isArray(value: any): value is any[] {\n  return Array.isArray(value);\n}\n\nexport const toArray = Array.from;\n\n\nexport const doc = document\n\n","import {\n  addEventListener,\n  DelegatedEvents,\n  delegateEvents,\n  effect,\n  insert,\n} from \"solid-js/web\";\nimport { isFunction, isString } from \"./util\";\nimport { AssignmentRule } from \"./types\";\n\n\n\n\nexport function assignEvent(\n  node: Element,\n  name: string,\n  value: any,\n  prev?: any\n) {\n  prev && node.removeEventListener(name, prev);\n  value && node.addEventListener(name, value);\n  return value;\n}\n\nexport function assignDelegatedEvent(\n  node: Element,\n  name: string,\n  value: any,\n  prev?: any\n) {\n  name = name.toLowerCase()\n  let delegate = DelegatedEvents.has(name);\n  addEventListener(node, name, value, delegate);\n  if (delegate) delegateEvents([name]);\n  return value;\n}\n\nexport function assignProperty(\n  node: Element,\n  name: string,\n  value: any,\n  prev?: any\n) {\n  (node as any)[name] = value;\n  return value;\n}\n\nexport function assignBooleanAttribute(\n  node: Element,\n  name: string,\n  value: any,\n  prev?: any\n) {\n  if (value) {\n    node.setAttribute(name, \"\");\n  } else {\n    node.removeAttribute(name);\n  }\n  return value;\n}\n\nexport function assignAttribute(\n  node: Element,\n  name: string,\n  value: any,\n  prev?: any\n) {\n  if (value === null || value === undefined) {\n    node.removeAttribute(name);\n    return value;\n  }\n  node.setAttribute(name, value);\n  return value;\n}\n\nexport function assignAttributeNS(\n  namespace: string,\n  node: Element,\n  name: string,\n  value: any,\n  prev?: any,\n) {\n  if (value === null || value === undefined) {\n    node.removeAttributeNS(namespace, name);\n    return value;\n  }\n  node.setAttributeNS(namespace, name, value);\n  return value;\n}\n\nexport function assignClass(\n  node: Element,\n  name: string,\n  value: any,\n  prev?: any\n) {\n  node.classList.toggle(name, !!value);\n  return value;\n}\n\nexport function assignStyle(\n  node: Element,\n  name: string,\n  value: any,\n  prev?: any\n) {\n  (node as HTMLElement).style[name as any] = value ? value : \"\";\n  return value;\n}\n\n\nexport function assignRef(node: Element, name: string, value: any, prev?: any) {\n  if (isFunction(value)) {\n    value(node);\n  }\n}\n\nexport function assign(\n  rules: AssignmentRule[],\n  elem: Element,\n  name: string,\n  value: any,\n  prev?: any\n) {\n  if (value === prev) return value;\n  if (name === \"children\") {\n    return insert(elem, value);\n  }\n\n  for (const rule of rules) {\n    const { filter, assign, isReactive = true } = rule;\n    if (isString(filter) && name.startsWith(filter)) {\n      name = name.slice(filter.length);\n    } else if (isFunction(filter)) {\n      name = filter(elem, name, value, prev);\n    } else {\n      continue;\n    }\n    if (name) {\n      if (isFunction(value) && isReactive) {\n        effect(() => (prev = assign(elem, name, value(), prev)));\n      } else {\n        assign(elem, name, value, prev);\n      }\n      return prev;\n    }\n  }\n}\n\n\n\nexport function spread(\n  rules: AssignmentRule[],\n  elem: Element,\n  props: any,\n  prev: any = {}\n) {\n\n  if (isFunction(props)) {\n    effect(() => {\n      for (const [name, value] of Object.entries(props())) {\n        prev[name] = assign(rules, elem, name, value, prev[name]);\n      }\n    });\n  } else {\n    for (const [name, value] of Object.entries(props)) {\n      prev[name] = assign(rules, elem, name, value, prev[name]);\n    }\n  }\n  return prev;\n}\n\n","// Added to an attribute name to mark the attribute as bound so we can find\n// it easily.\nexport const boundAttributeSuffix = \"$lit$\";\n\n// This marker is used in many syntactic positions in HTML, so it must be\n// a valid element name and attribute name. We don't support dynamic names (yet)\n// but this at least ensures that the parse tree is closer to the template\n// intention.\nexport const marker = `lit$marker$`;\n\n// String used to tell if a comment is a marker comment\nexport const markerMatch = \"?\" + marker;\n\n// Text used to insert a comment marker node. We use processing instruction\n// syntax because it's slightly smaller, but parses as a comment node.\nexport const nodeMarker = `<${markerMatch}>`;\n\n\nconst SPACE_CHAR = `[ \\t\\n\\f\\r]`;\nconst ATTR_VALUE_CHAR = `[^ \\t\\n\\f\\r\"'\\`<>=]`;\nconst NAME_CHAR = `[^\\\\s\"'>=/]`;\n\n// These regexes represent the five parsing states that we care about in the\n// Template's HTML scanner. They match the *end* of the state they're named\n// after.\n// Depending on the match, we transition to a new state. If there's no match,\n// we stay in the same state.\n// Note that the regexes are stateful. We utilize lastIndex and sync it\n// across the multiple regexes used. In addition to the five regexes below\n// we also dynamically create a regex to find the matching end tags for raw\n// text elements.\n\n/**\n * End of text is: `<` followed by:\n *   (comment start) or (tag) or (dynamic tag binding)\n */\nconst textEndRegex = /<(?:(!--|\\/[^a-zA-Z])|(\\/?[a-zA-Z][^>\\s]*)|(\\/?$))/g;\nconst COMMENT_START = 1;\nconst TAG_NAME = 2;\nconst DYNAMIC_TAG_NAME = 3;\n\nconst commentEndRegex = /-->/g;\n/**\n * Comments not started with <!--, like </{, can be ended by a single `>`\n */\nconst comment2EndRegex = />/g;\n\n/**\n * The tagEnd regex matches the end of the \"inside an opening\" tag syntax\n * position. It either matches a `>`, an attribute-like sequence, or the end\n * of the string after a space (attribute-name position ending).\n *\n * See attributes in the HTML spec:\n * https://www.w3.org/TR/html5/syntax.html#elements-attributes\n *\n * \" \\t\\n\\f\\r\" are HTML space characters:\n * https://infra.spec.whatwg.org/#ascii-whitespace\n *\n * So an attribute is:\n *  * The name: any character except a whitespace character, (\"), ('), \">\",\n *    \"=\", or \"/\". Note: this is different from the HTML spec which also excludes control characters.\n *  * Followed by zero or more space characters\n *  * Followed by \"=\"\n *  * Followed by zero or more space characters\n *  * Followed by:\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\n *    * (\") then any non-(\"), or\n *    * (') then any non-(')\n */\nconst tagEndRegex = new RegExp(\n  `>|${SPACE_CHAR}(?:(${NAME_CHAR}+)(${SPACE_CHAR}*=${SPACE_CHAR}*(?:${ATTR_VALUE_CHAR}|(\"|')|))|$)`,\n  \"g\"\n);\nconst ENTIRE_MATCH = 0;\nconst ATTRIBUTE_NAME = 1;\nconst SPACES_AND_EQUALS = 2;\nconst QUOTE_CHAR = 3;\n\nconst singleQuoteAttrEndRegex = /'/g;\nconst doubleQuoteAttrEndRegex = /\"/g;\n/**\n * Matches the raw text elements.\n *\n * Comments are not parsed within raw text elements, so we need to search their\n * text content for marker strings.\n */\nconst rawTextElement = /^(?:script|style|textarea|title)$/i;\n\n/** TemplateResult types */\nexport const HTML_RESULT = 1;\nexport const SVG_RESULT = 2;\nexport const MATHML_RESULT = 3;\n\nexport type ResultType = typeof HTML_RESULT | typeof SVG_RESULT | typeof MATHML_RESULT;\n\n\n\n/**\n * Returns an HTML string for the given TemplateStringsArray and result type\n * (HTML or SVG), along with the case-sensitive bound attribute names in\n * template order. The HTML contains comment markers denoting the `ChildPart`s\n * and suffixes on bound attributes denoting the `AttributeParts`.\n *\n * @param strings template strings array\n * @param type HTML or SVG\n * @return Array containing `[html, attrNames]` (array returned for terseness,\n *     to avoid object fields since this code is shared with non-minified SSR\n *     code)\n */\nexport const getTemplateHtml = (\n  strings: TemplateStringsArray,\n  type: ResultType\n): [string, Array<string>] => {\n  // Insert makers into the template HTML to represent the position of\n  // bindings. The following code scans the template strings to determine the\n  // syntactic position of the bindings. They can be in text position, where\n  // we insert an HTML comment, attribute value position, where we insert a\n  // sentinel string and re-write the attribute name, or inside a tag where\n  // we insert the sentinel string.\n  const l = strings.length - 1;\n  // Stores the case-sensitive bound attribute names in the order of their\n  // parts. ElementParts are also reflected in this array as undefined\n  // rather than a string, to disambiguate from attribute bindings.\n  const attrNames: Array<string> = [];\n  let html =\n    type === SVG_RESULT ? \"<svg>\" : type === MATHML_RESULT ? \"<math>\" : \"\";\n\n  // When we're inside a raw text tag (not it's text content), the regex\n  // will still be tagRegex so we can find attributes, but will switch to\n  // this regex when the tag ends.\n  let rawTextEndRegex: RegExp | undefined;\n\n  // The current parsing state, represented as a reference to one of the\n  // regexes\n  let regex = textEndRegex;\n\n  for (let i = 0; i < l; i++) {\n    const s = strings[i];\n    // The index of the end of the last attribute name. When this is\n    // positive at end of a string, it means we're in an attribute value\n    // position and need to rewrite the attribute name.\n    // We also use a special value of -2 to indicate that we encountered\n    // the end of a string in attribute name position.\n    let attrNameEndIndex = -1;\n    let attrName: string | undefined;\n    let lastIndex = 0;\n    let match!: RegExpExecArray | null;\n\n    // The conditions in this loop handle the current parse state, and the\n    // assignments to the `regex` variable are the state transitions.\n    while (lastIndex < s.length) {\n      // Make sure we start searching from where we previously left off\n      regex.lastIndex = lastIndex;\n      match = regex.exec(s);\n      if (match === null) {\n        break;\n      }\n      lastIndex = regex.lastIndex;\n      if (regex === textEndRegex) {\n        if (match[COMMENT_START] === \"!--\") {\n          regex = commentEndRegex;\n        } else if (match[COMMENT_START] !== undefined) {\n          // We started a weird comment, like </{\n          regex = comment2EndRegex;\n        } else if (match[TAG_NAME] !== undefined) {\n          if (rawTextElement.test(match[TAG_NAME])) {\n            // Record if we encounter a raw-text element. We'll switch to\n            // this regex at the end of the tag.\n            rawTextEndRegex = new RegExp(`</${match[TAG_NAME]}`, \"g\");\n          }\n          regex = tagEndRegex;\n        } else if (match[DYNAMIC_TAG_NAME] !== undefined) {\n          regex = tagEndRegex;\n        }\n      } else if (regex === tagEndRegex) {\n        if (match[ENTIRE_MATCH] === \">\") {\n          // End of a tag. If we had started a raw-text element, use that\n          // regex\n          regex = rawTextEndRegex ?? textEndRegex;\n          // We may be ending an unquoted attribute value, so make sure we\n          // clear any pending attrNameEndIndex\n          attrNameEndIndex = -1;\n        } else if (match[ATTRIBUTE_NAME] === undefined) {\n          // Attribute name position\n          attrNameEndIndex = -2;\n        } else {\n          attrNameEndIndex = regex.lastIndex - match[SPACES_AND_EQUALS].length;\n          attrName = match[ATTRIBUTE_NAME];\n          regex =\n            match[QUOTE_CHAR] === undefined\n              ? tagEndRegex\n              : match[QUOTE_CHAR] === '\"'\n              ? doubleQuoteAttrEndRegex\n              : singleQuoteAttrEndRegex;\n        }\n      } else if (\n        regex === doubleQuoteAttrEndRegex ||\n        regex === singleQuoteAttrEndRegex\n      ) {\n        regex = tagEndRegex;\n      } else if (regex === commentEndRegex || regex === comment2EndRegex) {\n        regex = textEndRegex;\n      } else {\n        // Not one of the five state regexes, so it must be the dynamically\n        // created raw text regex and we're at the close of that element.\n        regex = tagEndRegex;\n        rawTextEndRegex = undefined;\n      }\n    }\n\n    // We have four cases:\n    //  1. We're in text position, and not in a raw text element\n    //     (regex === textEndRegex): insert a comment marker.\n    //  2. We have a non-negative attrNameEndIndex which means we need to\n    //     rewrite the attribute name to add a bound attribute suffix.\n    //  3. We're at the non-first binding in a multi-binding attribute, use a\n    //     plain marker.\n    //  4. We're somewhere else inside the tag. If we're in attribute name\n    //     position (attrNameEndIndex === -2), add a sequential suffix to\n    //     generate a unique attribute name.\n\n    // Detect a binding next to self-closing tag end and insert a space to\n    // separate the marker from the tag end:\n    const end =\n      regex === tagEndRegex && strings[i + 1].startsWith(\"/>\") ? \" \" : \"\";\n    html +=\n      regex === textEndRegex\n        ? s + nodeMarker\n        : attrNameEndIndex >= 0\n        ? (attrNames.push(attrName!),\n          s.slice(0, attrNameEndIndex) +\n            boundAttributeSuffix +\n            s.slice(attrNameEndIndex)) +\n          marker +\n          end\n        : s + marker + (attrNameEndIndex === -2 ? i : end);\n  }\n\n  const htmlResult: string =\n    html +\n    (strings[l] || \"<?>\") +\n    (type === SVG_RESULT ? \"</svg>\" : type === MATHML_RESULT ? \"</math>\" : \"\");\n\n  // Returned as an array for terseness\n  return [htmlResult, attrNames];\n};\n","import { type JSX } from \"solid-js\";\nimport {\n  effect,\n  insert,\n  SVGElements\n} from \"solid-js/web\";\n\nimport {\n  boundAttributeSuffix,\n  getTemplateHtml,\n  HTML_RESULT,\n  marker,\n  markerMatch,\n  MATHML_RESULT,\n  ResultType,\n  SVG_RESULT,\n} from \"./lit-html\";\nimport { doc, isFunction } from \"./util\";\nimport { AssignmentRule } from \"./types\";\nimport { assign, spread } from \"./assign\";\nimport { defaultRules } from \"./defaults\";\n\n\n\ntype Template = [element: HTMLTemplateElement, attributes: string[]];\n\nconst walker = doc.createTreeWalker(doc, 129);\n\nconst templateCache = new WeakMap<TemplateStringsArray, Template>();\n\n/**\n * Returns a parsed template and its bound attributes for a given template string and type.\n * @internal\n */\nfunction getTemplate(\n  strings: TemplateStringsArray,\n  type: ResultType\n): Template {\n  let template = templateCache.get(strings);\n  if (template === undefined) {\n    const [html, attributes] = getTemplateHtml(strings, type);\n    const element = doc.createElement(\"template\");\n    element.innerHTML = html;\n    template = [element, attributes];\n    templateCache.set(strings, template);\n  }\n  return template;\n}\n\n\n\n/**\n * Creates a tagged template function for html/svg/mathml templates with Solid reactivity.\n * @internal\n */\nexport function HTML(type: ResultType = 1, rules: AssignmentRule[] = []) {\n  function html(\n    strings: TemplateStringsArray,\n    ...values: any[]\n  ): JSX.Element {\n\n    const [element, attributes] = getTemplate(strings, type);\n    const clone = element.content.cloneNode(true);\n\n    let valueIndex = 0;\n    let boundAttributeIndex = 0;\n    walker.currentNode = clone;\n\n    while (walker.nextNode()) {\n      const node = walker.currentNode;\n      if (node.nodeType === 1) {\n        for (const attr of [...(node as Element).attributes]) {\n          if (attr.name.endsWith(boundAttributeSuffix)) {\n            //Bound attribute/prop/event\n            let value: any\n            if (attr.value === marker) {\n              value = values[valueIndex++];\n            } else {\n              const strings = attr.value.split(marker);\n              let parts = [strings[0]] as any[];\n              for (let j = 1; j < strings.length; j++) {\n                parts.push(values[valueIndex++], strings[j]);\n              }\n              value = () => parts.map((v) => (isFunction(v) ? v() : v)).join(\"\");\n\n            }\n            assign(html.rules, node as Element, attributes[boundAttributeIndex++], value);\n            (node as Element).removeAttribute(attr.name);\n          } else if (attr.name === `...${marker}`) {\n            //Spread\n            const isSvg = SVGElements.has((node as Element).tagName);\n            const value = values[valueIndex++];\n            if (isFunction(value)) {\n              effect(() => spread(html.rules, node as Element, value()));\n            } else {\n              spread(html.rules, node as Element, value);\n            }\n            (node as Element).removeAttribute(attr.name);\n          } else if (attr.name.startsWith(marker)) {\n            //Refs\n            const value = values[valueIndex++];\n            if (isFunction(value)) {\n              value(node as Element);\n            }\n            (node as Element).removeAttribute(attr.name);\n          }\n        }\n      } else if (node.nodeType === 8) {\n        if (node.nodeValue === markerMatch) {\n          node.nodeValue = marker + valueIndex; //I don't know why, but this prevents misplaced elements\n          const value = values[valueIndex++];\n          const parent = node.parentNode;\n          if (parent) insert(parent, value, node);\n        }\n      }\n    }\n    if (type === SVG_RESULT || type === MATHML_RESULT) {\n      return [...clone.firstChild!.childNodes];\n    }\n    return [...clone.childNodes];\n  }\n\n\n  html.rules = [...rules, ...defaultRules];\n\n  return html;\n}\n\n","import { xmlNamespaces } from \"./defaults\";\nimport { H } from \"./h\";\nimport { AssignmentRule, ComponentRegistry } from \"./types\";\nimport { doc, isFunction, toArray } from \"./util\";\n\nconst start = `$START$`\nconst end = `$END$`\nconst match = /\\$START\\$(\\d+)\\$END\\$/g\n\nconst xmlCache = new WeakMap<TemplateStringsArray, Node>();\n\n/**\n * Parses a template string as XML and returns the child nodes, using a cache for performance.\n * @internal\n */\nfunction getXml(strings: TemplateStringsArray, xmlns: string[]) {\n  let xml = xmlCache.get(strings);\n  if (xml === undefined) {\n    let contents = \"\", i = 0\n    const l = strings.length\n    //Join XML with index so proper value can be extracted later independent of when it's executed\n    for (i; i < l - 1; i++) {\n      const part = strings[i]\n      // Allows no quotes for single attribute. Causes edge case for =${} in text nodes or within attribute values. Can be fixed with ${'=' + var}\n      if (part.endsWith(\"=\")) {\n        contents += `${part}\"${start}${i}${end}\"`\n      } else {\n        contents += `${part}${start}${i}${end}`\n      }\n    }\n    contents += strings.at(-1)\n\n    const namespaces = xmlns\n      .map((ns) => `xmlns:${ns}=\"/\"`)\n      .join(\" \");\n\n    const parser = new DOMParser();\n    xml = parser.parseFromString(`<xml ${namespaces}>${contents}</xml>`, \"text/xml\")\n      .firstChild!;\n    xmlCache.set(strings, xml);\n  }\n  return xml.childNodes;\n}\n\nconst flat = (arr: any) => (arr.length === 1 ? arr[0] : arr);\nfunction getValue(value: any) {\n  while (isFunction(value)) value = value();\n  return value;\n}\n\nfunction extractValues(values: any[], value: string | null, convertMultiPartToString = false) {\n  if (value === null) return null\n  const matches = toArray(value.matchAll(match))\n  if (matches.length) {\n    if (matches[0][0] === matches[0].input.trim()) {\n      return values[Number(matches[0][1])];\n    } else {\n      let index = 0\n      const parts = value.split(match).map((x, i) => (i % 2 === 1 ? values[Number(matches[index++][1])] : x));\n      return convertMultiPartToString ? () => parts.map(getValue).join(\"\") : parts\n    }\n  }\n  return value\n}\n\nexport function XML(components: ComponentRegistry = {}, rules: AssignmentRule[] = [], xmlns: string[] = []) {\n  function xml(template: TemplateStringsArray, ...values: any[]) {\n    const cached = getXml(template, xml.xlmns);\n\n    function nodes(node: Node) {\n      if (node.nodeType === 1) {\n        // Element Node\n        const { tagName, childNodes, attributes } = (node as Element);\n\n        // gather props\n        const props = {} as Record<string, any>;\n        for (let { name, value } of attributes) {\n          props[name] = extractValues(values, value, true);\n        }\n\n        // children - childNodes overwrites any props.children\n        if (childNodes.length) {\n          props.children = () => flat(toArray(childNodes).map(nodes));\n        }\n\n        return xml.h(tagName, props);\n      } else if (node.nodeType === 3) {\n        // Text Node\n        return extractValues(values, node.nodeValue);\n      } else if (node.nodeType === 8) {\n        // Comment Node\n        return doc.createComment(extractValues(values, node.nodeValue, true));\n      } else {\n        console.error(`xml: nodeType not supported ${node.nodeType}`);\n      }\n    }\n\n    return flat(toArray(cached).map(nodes));\n  }\n\n  xml.xlmns = [...xmlNamespaces, ...xmlns]\n  xml.h = H(components, rules);\n\n  return xml;\n}\n","import {\n  Dynamic,\n  ErrorBoundary,\n  For,\n  Index,\n  Match,\n  NoHydration,\n  Portal,\n  Show,\n  Suspense,\n  Switch,\n} from \"solid-js/web\";\nimport {\n  assignAttribute,\n  assignBooleanAttribute,\n  assignClass,\n  assignDelegatedEvent,\n  assignEvent,\n  assignProperty,\n  assignRef,\n  assignStyle\n} from \"./assign\";\nimport { H } from \"./h\";\nimport { HTML } from \"./html\";\nimport { HTML_RESULT, MATHML_RESULT, SVG_RESULT } from \"./lit-html\";\nimport { AssignmentRule, ComponentRegistry } from \"./types\";\nimport { XML } from \"./xml\";\n\n\nexport const defaultRules: AssignmentRule[] = [\n  { filter: \"on:\", assign: assignEvent, isReactive: false },\n  { filter: \"on\", assign: assignDelegatedEvent, isReactive: false },\n  { filter: \"prop:\", assign: assignProperty },\n  { filter: \"bool:\", assign: assignBooleanAttribute },\n  { filter: \"attr:\", assign: assignAttribute },\n  { filter: \"ref:\", assign: assignRef, isReactive: false },\n  { filter: \"class:\", assign: assignClass },\n  { filter: \"style:\", assign: assignStyle },\n  { filter: \"@\", assign: assignDelegatedEvent, isReactive: false },\n  { filter: \".\", assign: assignProperty },\n  { filter: \"?\", assign: assignBooleanAttribute },\n  { filter: \"\", assign: assignAttribute } //default\n]\n\n\n\nexport const defaultComponents: ComponentRegistry = {\n  For,\n  Index,\n  Match,\n  Suspense,\n  ErrorBoundary,\n  Show,\n  Switch,\n  Dynamic,\n  Portal,\n  NoHydration,\n}\n\nexport const xmlNamespaces = [\"on\", \"prop\", \"bool\", \"attr\", \"ref\", \"style\", \"class\", \"xlink\"]\n\n\nexport const h = H();\n\nexport const xml = XML()\n//link global xml with global h\nxml.h = h\n\nexport const html = HTML(HTML_RESULT);\n\nexport const svg = HTML(SVG_RESULT);\n\nexport const mathml = HTML(MATHML_RESULT);\n","import {\n  createComponent,\n  type ComponentProps,\n  type JSX,\n  type ValidComponent,\n} from \"solid-js\";\n\nimport { spread } from \"./assign\";\nimport { defaultComponents, defaultRules } from \"./defaults\";\n\nimport { doc, isFunction, isString } from \"./util\";\nimport { SVGElements } from \"solid-js/web\";\nimport { AssignmentRule, MaybeFunctionProps } from \"./types\";\n\nexport function H(components: Record<string, any> = {}, rules: AssignmentRule[] = []) {\n\n  function h<T extends ValidComponent>(\n    component: T,\n    props: MaybeFunctionProps<ComponentProps<T>>,\n    ...children: JSX.Element[]\n  ): JSX.Element {\n    //children in spread syntax override children in props\n    if (children.length === 1) {\n      //@ts-expect-error\n      props.children = children[0];\n    } else if (children.length > 1) {\n      //@ts-expect-error\n      props.children = children;\n    }\n\n    if (isString(component)) {\n      const componentFunction = (h.components)[component];\n      if (componentFunction) {\n        return createComponent(componentFunction, wrapProps(props));\n      }\n      \n      if (/[A-Z]/.test(component)) {\n        console.warn(`Forgot to define ${componentFunction}`);\n      }\n\n      const elem = SVGElements.has(component) ? doc.createElementNS(\"http://www.w3.org/2000/svg\", component) : doc.createElement(component);\n      spread(h.rules, elem, props);\n      return elem;\n    } else if (isFunction(component)) {\n      return createComponent(component, wrapProps(props));\n    }\n  }\n  h.components = {...defaultComponents, ...components};\n  h.define = (components: Record<string, ValidComponent>) => {\n    Object.assign(h.components, components);\n  };\n  h.rules = [...rules, ...defaultRules];\n\n\n  return h;\n\n}\n\n\nexport const markedOnce = new WeakSet();\n\n/**\n * Marks a function so it is not wrapped as a getter by h().\n * Useful for event handlers or functions that should not be auto-accessed.\n * @example\n * once(() => doSomething())\n */\nexport function once<T extends (...args: any[]) => any>(fn: T): T {\n  if (isFunction(fn)) markedOnce.add(fn);\n  return fn;\n}\n\n/**\n * Internal: Replaces accessor props with getters for reactivity, except for refs and event handlers.\n */\nexport function wrapProps<\n  TComponent extends ValidComponent,\n  TProps extends MaybeFunctionProps<ComponentProps<TComponent>>\n>(props: TProps = {} as TProps): ComponentProps<TComponent> {\n  for (const [key, descriptor] of Object.entries(\n    Object.getOwnPropertyDescriptors(props)\n  )) {\n    const value = descriptor.value;\n    if (isFunction(value) && value.length === 0 && !markedOnce.has(value)) {\n      Object.defineProperty(props, key, {\n        get() {\n          return value();\n        },\n        enumerable: true,\n      });\n    }\n  }\n  return props as ComponentProps<TComponent>;\n}\n"],"mappings":"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"}