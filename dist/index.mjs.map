{"version":3,"file":"index.mjs","names":["value: any","data:string","tag: string","arr: any[]","input: TemplateStringsArray","html5parse","nodes: INode[]","node: INode","name","value: string","node: RootNode | ChildNode","node: ChildNode","components: T","sld","strings: TemplateStringsArray","newComponents: TNew","node: ChildNode","values: any[]","components: ComponentRegistry","node: ComponentNode | RootNode | ElementNode","nodes: ChildNode[]","node","node: ElementNode | ComponentNode","props: Record<string, any>","spread","name: string","value: any","component: T"],"sources":["../src/util.ts","../src/parse.ts","../src/template.ts","../src/sld.ts","../src/index.ts"],"sourcesContent":["import { SVGElements } from \"solid-js/web\";\r\n\r\n\r\nexport function isString(value: any): value is string {\r\n  return typeof value === \"string\";\r\n}\r\n\r\nexport function isNumber(value: any): value is number {\r\n  return typeof value === \"number\";\r\n}\r\n\r\nexport function isFunction(value: any): value is Function {\r\n  return typeof value === \"function\";\r\n}\r\n\r\nexport function isBoolean(value: any): value is boolean {\r\n  return typeof value === \"boolean\";\r\n}\r\n\r\nexport function isObject(value: any): value is object {\r\n  return typeof value === \"object\";\r\n}\r\n\r\nexport function isArray(value: any): value is any[] {\r\n  return Array.isArray(value);\r\n}\r\n\r\nexport const toArray = Array.from;\r\n\r\n\r\nexport const doc = document\r\n\r\nexport const createComment = (data:string)=>doc.createComment(data)\r\n\r\nexport function createElement(tag: string){\r\n  return SVGElements.has(tag) ? doc.createElementNS(\"http://www.w3.org/2000/svg\", tag) : doc.createElement(tag)\r\n}\r\n\r\nexport function flat(arr: any[]) {\r\n  return (arr.length === 1 ? arr[0] : arr);\r\n}\r\n\r\nexport function getValue(value: any) {\r\n  while (isFunction(value)) value = value();\r\n  return value;\r\n}","// WE use html5parser because it preservers case of tags and attributes\r\nimport {\r\n    SyntaxKind,\r\n    parse as html5parse,\r\n    type INode,\r\n    type IText\r\n} from \"html5parser\";\r\n\r\nimport { isNumber, isString } from \"./util\";\r\n\r\n\r\n//AST Node types\r\n\r\n//Non reactive text\r\nexport const TEXT_NODE = 1;\r\nexport type TextNode = {\r\n    type: typeof TEXT_NODE;\r\n    value: string;\r\n};\r\n\r\n//Non reactive Comment Node <!--value-->\r\nexport const COMMENT_NODE = 2;\r\nexport type CommentNode = {\r\n    type: typeof COMMENT_NODE;\r\n    value: string;\r\n};\r\n\r\n//Reactive Hole\r\nexport const INSERT_NODE = 3;\r\nexport type InsertNode = {\r\n    type: typeof INSERT_NODE;\r\n    value: number; //index of hole\r\n};\r\n\r\n//tag with lowercase first letter <div />\r\nexport const ELEMENT_NODE = 4;\r\nexport type ElementNode = {\r\n    type: typeof ELEMENT_NODE;\r\n    name: string;\r\n    props: Property[];\r\n    children: ChildNode[];\r\n};\r\n\r\n//Tag with capital first letter <Div />\r\nexport const COMPONENT_NODE = 5;\r\nexport type ComponentNode = {\r\n    type: typeof COMPONENT_NODE;\r\n    name: string;\r\n    props: Property[];\r\n    children: ChildNode[];\r\n    template?: HTMLTemplateElement\r\n};\r\n\r\nexport const ROOT_NODE = 6;\r\nexport type RootNode = {\r\n    type: typeof ROOT_NODE;\r\n    children: ChildNode[];\r\n    template?: HTMLTemplateElement\r\n};\r\n\r\nexport type ChildNode =\r\n    | TextNode\r\n    | ComponentNode\r\n    | ElementNode\r\n    | InsertNode\r\n    | CommentNode;\r\n\r\nexport type Property = BooleanProperty | StringProperty | DynamicProperty | MixedProperty | SpreadProperty | AnonymousProperty\r\n\r\n// <input disabled>\r\nexport const BOOLEAN_PROPERTY = 1\r\nexport type BooleanProperty = {\r\n    type: typeof BOOLEAN_PROPERTY\r\n    name: string,\r\n}\r\n\r\n// <input value=\"myString\"> <input value='myString'> <input value=\"\"> <input value=''>\r\nexport const STRING_PROPERTY = 2\r\nexport type StringProperty = {\r\n    type: typeof STRING_PROPERTY\r\n    name: string,\r\n    value: string\r\n}\r\n\r\n// <input value=${}> <input value=\"${}\"\"> <input value='${}'>\r\nexport const DYNAMIC_PROPERTY = 3\r\nexport type DynamicProperty = {\r\n    type: typeof DYNAMIC_PROPERTY\r\n    name: string,\r\n    value: number\r\n}\r\n\r\n// <input value=\" ${}\"> <input value=\"input-${}\"> <input value='${\"value1\"} ${\"value2\"}'>\r\nexport const MIXED_PROPERTY = 4\r\nexport type MixedProperty = {\r\n    type: typeof MIXED_PROPERTY\r\n    name: string,\r\n    value: Array<string | number>\r\n}\r\n\r\n// <input ...${} />\r\nexport const SPREAD_PROPERTY = 5\r\nexport type SpreadProperty = {\r\n    type: typeof SPREAD_PROPERTY\r\n    value: number\r\n}\r\n\r\n// <input ${} />\r\nexport const ANONYMOUS_PROPERTY = 6\r\nexport type AnonymousProperty = {\r\n    type: typeof ANONYMOUS_PROPERTY\r\n    value: number\r\n}\r\n\r\n//string or boolean means static, number means hole and is index, array means mix of string and holes\r\nexport type ValueParts = string | boolean | number | Array<string | number>;\r\n\r\n//Needs to be unique character that would never be in the template literal\r\nconst marker = \"⧙⧘\";\r\n\r\n//Captures index of hole\r\nconst match = new RegExp(`${marker}(\\\\d+)${marker}`, \"g\");\r\n\r\n/**\r\n * \r\n * @param input jsx like string to parse\r\n * @returns RootNode of an AST\r\n */\r\nexport function parse(input: TemplateStringsArray): RootNode {\r\n    const ast = html5parse(\r\n        input\r\n            .slice(1)\r\n            .reduce(\r\n                (prev, current, index) => prev + marker + index + marker + current,\r\n                input[0],\r\n            ),\r\n    );\r\n    return {\r\n        type: ROOT_NODE,\r\n        children: parseNodes(ast)\r\n    }\r\n}\r\n\r\nfunction parseNodes(nodes: INode[]) {\r\n    return nodes.flatMap(parseNode)\r\n}\r\n\r\n//Parse html5parser result for what we care about\r\nfunction parseNode(\r\n    node: INode,\r\n): ChildNode | ChildNode[] {\r\n    //Text nodes are either static text or holes to insert in\r\n    if (node.type === SyntaxKind.Text) {\r\n        return node.value\r\n            .split(match).flatMap((value, index, array) => {\r\n                if (index % 2 === 1) {\r\n                    return {\r\n                        type: INSERT_NODE,\r\n                        value: Number(value)\r\n                    }\r\n                }\r\n                //We want to trim when only content in textnode is the hole or if textnode is empty\r\n                if (!value || (array.length === 3 && !value.trim())) {\r\n                    return []\r\n                }\r\n\r\n                return {\r\n                    type: TEXT_NODE,\r\n                    value,\r\n                }\r\n            });\r\n    }\r\n\r\n    //html5parser represents comments as type tag with name \"!\" or \"\"\r\n    if (node.name[0] === \"!\" || node.name === \"\") {\r\n        return {\r\n            type: COMMENT_NODE,\r\n            value: (node.body as IText[]).join(\"\"),\r\n        } as CommentNode;\r\n    }\r\n\r\n    const props = node.attributes.flatMap((v) => {\r\n        const nameParts = getParts(v.name.value);\r\n\r\n        if (nameParts.length === 1) {\r\n            const name = nameParts[0];\r\n            if (v.value === undefined) {\r\n                return {\r\n                    name,\r\n                    type: BOOLEAN_PROPERTY\r\n                }\r\n            }\r\n\r\n            if (isNumber(name)) {\r\n                return {\r\n                    type: ANONYMOUS_PROPERTY,\r\n                    value: nameParts[1]\r\n                }\r\n            }\r\n\r\n            const valueParts = getParts(v.value?.value);\r\n\r\n            if (valueParts.length === 0) {\r\n                return {\r\n                    name,\r\n                    type: BOOLEAN_PROPERTY\r\n                }\r\n            } else if (valueParts.length === 1) {\r\n                const value = valueParts[0]\r\n                if (isNumber(value)) {\r\n                    return {\r\n                        type: DYNAMIC_PROPERTY,\r\n                        name,\r\n                        value\r\n                    }\r\n                } else {\r\n                    return {\r\n                        type: STRING_PROPERTY,\r\n                        name,\r\n                        value\r\n                    }\r\n                }\r\n            } else {\r\n                return {\r\n                    type: MIXED_PROPERTY,\r\n                    name,\r\n                    value: valueParts\r\n                }\r\n            }\r\n        }\r\n\r\n        //name is mixed static and dynamic. We only look for ...${}\r\n        if (nameParts[0] === \"...\") {\r\n            return {\r\n                type: SPREAD_PROPERTY,\r\n                value: nameParts[1]\r\n            }\r\n        }\r\n\r\n        return []\r\n    }) as Property[];\r\n\r\n    const children = node.body?.flatMap(parseNode) ?? [];\r\n    const name = node.rawName as string;\r\n\r\n    return {\r\n        type: /^[A-Z]/.test(name) ? COMPONENT_NODE : ELEMENT_NODE,\r\n        name,\r\n        props,\r\n        children,\r\n    };\r\n}\r\n\r\n// Splits a string into static parts and hole indexes\r\nfunction getParts(value: string = \"\"): Array<string | number> {\r\n    return value\r\n        .split(match)\r\n        .map((v, i) => (i % 2 === 1 ? parseInt(v) : v))\r\n        .filter((v) => isNumber(v) || !v);\r\n}","import { COMMENT_NODE, COMPONENT_NODE, ELEMENT_NODE, INSERT_NODE, TEXT_NODE, ChildNode, RootNode, ComponentNode, ROOT_NODE, STRING_PROPERTY, BOOLEAN_PROPERTY } from \"./parse\";\r\nimport { createComment, createElement, isString } from \"./util\";\r\n\r\n\r\n\r\n\r\n//build template element with same exact shape as tree so they can be walked through in sync\r\nexport function buildTemplate(node: RootNode | ChildNode): void {\r\n    if (node.type === ROOT_NODE || node.type === COMPONENT_NODE) {\r\n        //Criteria for using template is component or root has at least 1 element. May be be a more optimal condition.\r\n        if (node.children.some((v) => v.type === ELEMENT_NODE)) {\r\n            const template = document.createElement(\"template\");\r\n            // buildNodes(node.children, template.content);\r\n            template.innerHTML = node.children.map(buildHTML).join(\"\");\r\n            node.template = template\r\n        }\r\n        node.children.forEach(buildTemplate)\r\n    }\r\n    if (node.type === ELEMENT_NODE) {\r\n        node.children.forEach(buildTemplate)\r\n    }\r\n}\r\n\r\n\r\n//Lets browser handle svg,mathml, and html encoding\r\nfunction buildHTML(node: ChildNode): string {\r\n    switch (node.type) {\r\n        case TEXT_NODE:\r\n            return node.value;\r\n        case COMMENT_NODE:\r\n            return `<!--${node.value}-->`;\r\n        case INSERT_NODE:\r\n            return `<!--+-->`;\r\n        case COMPONENT_NODE:\r\n            return `<!--${node.name}-->`;\r\n        case ELEMENT_NODE:\r\n            let attributeHTML=\"\"\r\n            node.props = node.props.filter((prop) => {\r\n                if (prop.type === STRING_PROPERTY) {\r\n                    attributeHTML+=` ${prop.name}=\"${prop.value}\"`\r\n                    return;\r\n                } else if (prop.type===BOOLEAN_PROPERTY) {\r\n                    attributeHTML+=` ${prop.name}`\r\n                    return;\r\n                }\r\n                return true;\r\n            });\r\n\r\n\r\n            return `<${node.name}${attributeHTML}>${node.children.map(buildHTML).join(\"\")}</${node.name}>`;\r\n    }\r\n}\r\n\r\n//Building manually requires checking for MathML, SVG tags as well as html encoded chars\r\nfunction buildNodes(nodes: ChildNode[], parent: Node) {\r\n    for (const node of nodes) {\r\n        switch (node.type) {\r\n            case TEXT_NODE:\r\n                parent.appendChild(document.createTextNode(node.value));\r\n                break;\r\n            case COMMENT_NODE:\r\n                parent.appendChild(createComment(node.value));\r\n                break;\r\n            case INSERT_NODE:\r\n                parent.appendChild(createComment(\"+\"));\r\n                break;\r\n            case COMPONENT_NODE:\r\n                parent.appendChild(createComment(node.name));\r\n                break;\r\n            case ELEMENT_NODE:\r\n                const elem = createElement(node.name);\r\n                parent.appendChild(elem);\r\n\r\n                //set static attributes only and remove from props\r\n                node.props = node.props.filter((prop) => {\r\n                    if (prop.type === STRING_PROPERTY) {\r\n                        elem.setAttribute(prop.name, prop.value);\r\n                        return;\r\n                    } else if (prop.type===BOOLEAN_PROPERTY) {\r\n                        elem.setAttribute(prop.name, \"\"); //boolean attribute\r\n                        return;\r\n                    }\r\n                    return true;\r\n                });\r\n                buildNodes(node.children, elem);\r\n                break;\r\n        }\r\n    }\r\n}\r\n\r\n","import { JSX, createComponent, mergeProps } from \"solid-js\";\r\nimport { SVGElements, insert, spread } from \"solid-js/web\";\r\nimport {\r\n  ANONYMOUS_PROPERTY,\r\n  BOOLEAN_PROPERTY,\r\n  COMMENT_NODE,\r\n  COMPONENT_NODE,\r\n  ChildNode,\r\n  ComponentNode,\r\n  DYNAMIC_PROPERTY,\r\n  ELEMENT_NODE,\r\n  ElementNode,\r\n  INSERT_NODE,\r\n  MIXED_PROPERTY,\r\n  ROOT_NODE,\r\n  RootNode,\r\n  SPREAD_PROPERTY,\r\n  STRING_PROPERTY,\r\n  TEXT_NODE,\r\n  parse,\r\n} from \"./parse\";\r\nimport { buildTemplate } from \"./template\";\r\nimport { ComponentRegistry, SLDInstance } from \"./types\";\r\nimport {\r\n  createComment,\r\n  createElement,\r\n  flat,\r\n  getValue,\r\n  isFunction,\r\n  isNumber,\r\n  isObject,\r\n  toArray\r\n} from \"./util\";\r\n\r\nconst cache = new WeakMap<TemplateStringsArray, RootNode>();\r\n\r\n//Walk over text, comment, and element nodes\r\nconst walker = document.createTreeWalker(document, 133);\r\n\r\n\r\n//Factory function to create new SLD instances.\r\nexport function createSLD<T extends ComponentRegistry>(components: T): SLDInstance<T> {\r\n  function sld(strings: TemplateStringsArray, ...values: any[]) {\r\n    const root = getCachedRoot(strings);\r\n\r\n    return renderChildren(root, values, components);\r\n  }\r\n  sld.components = components;\r\n  sld.sld = sld;\r\n  sld.define = function define<TNew extends ComponentRegistry>(\r\n    newComponents: TNew\r\n  ) {\r\n    return createSLD({ ...components, ...newComponents });\r\n  };\r\n\r\n\r\n  return sld as SLDInstance<T>;\r\n}\r\n\r\nfunction getCachedRoot(strings: TemplateStringsArray): RootNode {\r\n  let root = cache.get(strings);\r\n  if (!root) {\r\n    root = parse(strings);\r\n    buildTemplate(root);\r\n    cache.set(strings, root);\r\n    // console.log(root)\r\n  }\r\n  return root;\r\n}\r\n\r\nfunction renderNode(\r\n  node: ChildNode,\r\n  values: any[],\r\n  components: ComponentRegistry\r\n): any {\r\n  switch (node.type) {\r\n    case TEXT_NODE:\r\n      return node.value;\r\n    case INSERT_NODE:\r\n      return values[node.value];\r\n    case COMMENT_NODE:\r\n      return createComment(node.value);\r\n    case ELEMENT_NODE:\r\n      const element = createElement(node.name);\r\n      spread(\r\n        element,\r\n        gatherProps(node, values, components),\r\n        SVGElements.has(node.name),\r\n        true\r\n      );\r\n      return element;\r\n    case COMPONENT_NODE:\r\n      const component = components[node.name];\r\n      if (!component) throw new Error(`${node.name} is not defined`);\r\n      return createComponent(component, gatherProps(node, values, components));\r\n  }\r\n}\r\n\r\nfunction renderChildren(\r\n  node: ComponentNode | RootNode | ElementNode,\r\n  values: any[],\r\n  components: ComponentRegistry\r\n): JSX.Element {\r\n  const template =\r\n    (node.type === ROOT_NODE || node.type === COMPONENT_NODE) && node.template;\r\n  if (!template) {\r\n    return flat(node.children.map((n) => renderNode(n, values, components)));\r\n  }\r\n\r\n  const clone = template.content.cloneNode(true);\r\n  walker.currentNode = clone;\r\n  walkNodes(node.children);\r\n\r\n  function walkNodes(nodes: ChildNode[]) {\r\n    for (const node of nodes) {\r\n      const domNode = walker.nextNode()!;\r\n      if (node.type === ELEMENT_NODE) {\r\n        if (node.props.length) {\r\n          //Assigning props to element via assign prop w/effect may be better for performance.\r\n          const props = gatherProps(node, values, components);\r\n          spread(domNode as Element, props, SVGElements.has(node.name), true);\r\n        }\r\n\r\n        walkNodes(node.children);\r\n      } else if (node.type === INSERT_NODE || node.type === COMPONENT_NODE) {\r\n        insert(\r\n          domNode.parentNode!,\r\n          renderNode(node, values, components),\r\n          domNode\r\n        );\r\n        walker.currentNode = domNode;\r\n      }\r\n    }\r\n  }\r\n  return toArray(clone.childNodes);\r\n}\r\n\r\nfunction gatherProps(\r\n  node: ElementNode | ComponentNode,\r\n  values: any[],\r\n  components: ComponentRegistry,\r\n  props: Record<string, any> = {}\r\n) {\r\n  for (const prop of node.props) {\r\n    switch (prop.type) {\r\n\r\n      case BOOLEAN_PROPERTY:\r\n        props[prop.name] = true;\r\n        break;\r\n      case STRING_PROPERTY:\r\n        props[prop.name] = prop.value\r\n        break;\r\n      case DYNAMIC_PROPERTY:\r\n        applyGetter(props, prop.name, values[prop.value])\r\n        break;\r\n      case MIXED_PROPERTY:\r\n        const value = () =>\r\n          prop.value\r\n            .map((v) => (isNumber(v) ? getValue(values[v]) : v))\r\n            .join(\"\");\r\n        applyGetter(props, prop.name, value);\r\n        break;\r\n      case SPREAD_PROPERTY:\r\n        const spread = values[prop.value];\r\n        if (!isObject(spread)) throw new Error(\"Can only spread objects\");\r\n        props = mergeProps(props, spread);\r\n        break;\r\n      case ANONYMOUS_PROPERTY:\r\n        props.ref = values[prop.value];\r\n        break;\r\n    }\r\n  }\r\n\r\n  // children - childNodes overwrites any props.children\r\n  if (node.children.length) {\r\n    Object.defineProperty(props, \"children\", {\r\n      get() {\r\n        return renderChildren(node, values, components);\r\n      },\r\n    });\r\n  }\r\n  return props;\r\n}\r\n\r\n\r\nfunction applyGetter(props: Record<string, any>, name: string, value: any) {\r\n  if (\r\n    isFunction(value) &&\r\n    value.length === 0 &&\r\n    name !== \"ref\" &&\r\n    !name.startsWith(\"on\")\r\n  ) {\r\n    Object.defineProperty(props, name, {\r\n      get() {\r\n        return value();\r\n      },\r\n      enumerable: true,\r\n    });\r\n  } else {\r\n    props[name] = value;\r\n  }\r\n}","import { createComponent, ErrorBoundary, For, Index, Match, Show, Suspense, Switch } from \"solid-js\";\r\nimport { createSLD, } from \"./sld\";\r\nimport { type FunctionComponent, type SLDInstance } from \"./types\";\r\n\r\nexport { parse } from \"./parse\";\r\nexport { createSLD, SLDInstance };\r\n\r\n/**\r\n * Default components included with SLD. Can be extended with sld.define({MyComponent})\r\n */\r\nexport const defaultComponents = {\r\n    For,\r\n    Index,\r\n    Match,\r\n    Suspense,\r\n    ErrorBoundary,\r\n    Show,\r\n    Switch,\r\n};\r\n\r\n/**\r\n * Default SLD instance with basic components included. Can be extended with sld.define({MyComponent})\r\n */\r\nexport const sld = createSLD(defaultComponents)\r\nexport default sld\r\n\r\n/**\r\n * SLD factory function to create new SLD instances with built-in components.\r\n */\r\nexport const SLD = sld.define\r\n\r\n\r\n\r\n/**\r\n * Helper function for giving better typescript to components. Wrap in createComponent but keep same signature of function. Helps for overlaods.\r\n * @param component Function of component\r\n * @returns \r\n */\r\nexport function run<T extends FunctionComponent>(component: T): T {\r\n    //@ts-expect-error\r\n    return (props)=>createComponent(component, props)\r\n}"],"mappings":"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"}